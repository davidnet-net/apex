<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Vluchtsimulator - Pro Edition</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #000;
            user-select: none;
        }

        #hud {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            pointer-events: none;
            display: flex;
            justify-content: space-between;
            color: white;
            text-shadow: 1px 1px 2px black;
        }

        .instrument {
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            min-width: 120px;
            text-align: center;
            backdrop-filter: blur(5px);
        }

        .value {
            font-size: 24px;
            font-weight: bold;
            display: block;
        }

        .label {
            font-size: 12px;
            text-transform: uppercase;
            opacity: 0.8;
        }

        #compass-container {
            position: relative;
            width: 60px;
            height: 60px;
            margin: 0 auto 5px auto;
            border-radius: 50%;
            border: 2px solid white;
            background: rgba(0,0,0,0.3);
        }
        
        #compass-arrow {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 50px;
            background: red;
            transform-origin: center;
            transform: translate(-50%, -50%);
        }
        
        #compass-arrow::after {
            content: 'N';
            position: absolute;
            top: -15px;
            left: -4px;
            color: white;
            font-weight: bold;
            font-size: 12px;
        }

        #ready-display {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
            font-weight: bold;
            color: white;
            text-transform: uppercase;
            text-shadow: 1px 1px 2px black;
            background: rgba(0,0,0,0.5);
            padding: 10px 20px;
            border-radius: 20px;
            border: 2px solid white;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 0.8; }
            50% { opacity: 1; }
            100% { opacity: 0.8; }
        }

        #warning-box {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            pointer-events: none;
            display: none;
        }

        .warning-text {
            font-size: 40px;
            font-weight: bold;
            color: red;
            text-transform: uppercase;
            text-shadow: 2px 2px 0px black;
            animation: blink 0.3s infinite;
        }

        @keyframes blink {
            0% { opacity: 1; }
            50% { opacity: 0; }
            100% { opacity: 1; }
        }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: white;
            display: none;
            background: rgba(0,0,0,0.8);
            padding: 40px;
            border-radius: 20px;
            border: 2px solid red;
            z-index: 100;
        }

        #game-over h1 {
            color: red;
            font-size: 60px;
            margin: 0;
            text-transform: uppercase;
        }

        #instructions {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            text-align: center;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 20px;
            border-radius: 20px;
            pointer-events: none;
            font-size: 14px;
            text-shadow: 1px 1px 2px black;
            transition: opacity 1s;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="instructions">
        <b>Besturing (Inverted Y):</b><br>
        Muis omhoog = OMHOOG | Muis omlaag = OMLAAG<br>
        Houd <b>W</b> ingedrukt om op te stijgen<br>
        <span style="color: lightgreen">Druk 'F' voor Flap Levels (0-4) | Max Hoogte: 4000ft</span>
    </div>

    <div id="crosshair"></div>
    <div id="ready-display">GEREED VOOR VERTREK</div>

    <div id="warning-box">
        <div id="warning-msg" class="warning-text">STALL WAARSCHUWING</div>
    </div>

    <div id="game-over">
        <h1>CRASH!</h1>
        <p>Herstarten in <span id="restart-timer">5</span> seconden...</p>
    </div>

    <div id="hud">
        <div class="instrument">
            <span class="value" id="speed-display">0</span>
            <span class="label">Snelheid (km/h)</span>
        </div>
        <div class="instrument">
            <div id="compass-container">
                <div id="compass-arrow"></div>
            </div>
            <span class="label" id="heading-display">NOORD</span>
        </div>
        <div class="instrument">
            <span class="value" id="flaps-display">0</span>
            <span class="label">Flaps (F)</span>
        </div>
        <div class="instrument">
            <span class="value" id="alt-display">0</span>
            <span class="label">Hoogte (ft)</span>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // 50% kans op nacht
        const isNight = Math.random() > 0.5;
        const skyColor = isNight ? 0x050510 : 0x87CEEB;
        const ambientIntensity = isNight ? 0.2 : 0.6;
        const sunIntensity = isNight ? 0.1 : 0.8;

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(skyColor);
        scene.fog = new THREE.Fog(skyColor, 200, 2500); 

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 5000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, ambientIntensity);
        scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, sunIntensity);
        dirLight.position.set(100, 200, 50);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.left = -1000;
        dirLight.shadow.camera.right = 1000;
        dirLight.shadow.camera.top = 1000;
        dirLight.shadow.camera.bottom = -1000;
        scene.add(dirLight);

        let isGameOver = false;
        let explosionParticles = [];
        let obstacles = [];
        let gameStartTime = Date.now();

        const RUNWAY_LENGTH = 600;
        const RUNWAY_WIDTH = 40;
        const RUNWAY_HEIGHT = -78; 
        const PLANE_OFFSET = 2.5; 

        // Landingsbaan grid
        const runways = [];
        for(let x = -2; x <= 2; x++) {
            for(let z = -2; z <= 2; z++) {
                runways.push({
                    x: x * 4000,
                    z: z * 4000,
                    rotation: (Math.random() > 0.5 ? 0 : Math.PI / 2)
                });
            }
        }

        function createPlane() {
            const planeGroup = new THREE.Group();
            const fuselageColor = 0xffffff;
            const wingColor = 0xcc0000;

            const fuselageGeo = new THREE.ConeGeometry(2, 15, 32);
            fuselageGeo.rotateX(Math.PI / 2);
            const fuselage = new THREE.Mesh(fuselageGeo, new THREE.MeshPhongMaterial({ color: fuselageColor }));
            fuselage.castShadow = true;
            planeGroup.add(fuselage);

            const cockpit = new THREE.Mesh(new THREE.BoxGeometry(2.5, 2, 4), new THREE.MeshPhongMaterial({ color: 0x333333 }));
            cockpit.position.set(0, 1, 1);
            cockpit.castShadow = true;
            planeGroup.add(cockpit);

            const wings = new THREE.Mesh(new THREE.BoxGeometry(24, 0.5, 4), new THREE.MeshPhongMaterial({ color: wingColor }));
            wings.position.set(0, 0, 1);
            wings.castShadow = true;
            planeGroup.add(wings);

            const tail = new THREE.Mesh(new THREE.BoxGeometry(0.5, 4, 3), new THREE.MeshPhongMaterial({ color: wingColor }));
            tail.position.set(0, 1.5, -6);
            tail.castShadow = true;
            planeGroup.add(tail);
            
            const hStab = new THREE.Mesh(new THREE.BoxGeometry(8, 0.5, 2.5), new THREE.MeshPhongMaterial({ color: wingColor }));
            hStab.position.set(0, 0.5, -6);
            hStab.castShadow = true;
            planeGroup.add(hStab);

            const propGroup = new THREE.Group();
            const propGeo = new THREE.BoxGeometry(8, 0.2, 0.5);
            const propMat = new THREE.MeshPhongMaterial({ color: 0x333333 });
            const blade1 = new THREE.Mesh(propGeo, propMat);
            const blade2 = new THREE.Mesh(propGeo, propMat);
            blade2.rotation.z = Math.PI / 2;
            propGroup.add(blade1);
            propGroup.add(blade2);
            propGroup.position.set(0, 0, 7.6);
            planeGroup.add(propGroup);
            planeGroup.userData.propeller = propGroup;

            // Navigatieverlichting
            const lightGeo = new THREE.SphereGeometry(0.4, 8, 8);
            
            const redLight = new THREE.Mesh(lightGeo, new THREE.MeshBasicMaterial({ color: 0xff0000 }));
            redLight.position.set(-11.8, 0, 1);
            planeGroup.add(redLight);

            const greenLight = new THREE.Mesh(lightGeo, new THREE.MeshBasicMaterial({ color: 0x00ff00 }));
            greenLight.position.set(11.8, 0, 1);
            planeGroup.add(greenLight);

            const whiteLight = new THREE.Mesh(lightGeo, new THREE.MeshBasicMaterial({ color: 0xffffff }));
            whiteLight.position.set(0, 3.5, -7);
            planeGroup.add(whiteLight);
            planeGroup.userData.strobe = whiteLight;

            // Koplamp (Landing light) voor nachtvluchten
            if (isNight) {
                const landingLight = new THREE.SpotLight(0xffffff, 2, 300, Math.PI / 6, 0.5);
                landingLight.position.set(0, 0, 7);
                landingLight.target.position.set(0, -2, 50);
                planeGroup.add(landingLight);
                planeGroup.add(landingLight.target);
            }

            return planeGroup;
        }

        const airplane = createPlane();
        scene.add(airplane);

        function getNoiseHeight(x, z) {
            return (Math.sin(x * 0.01) * Math.cos(z * 0.01) * 30) + 
                   (Math.sin(x * 0.05) * Math.cos(z * 0.05) * 10) - 80;
        }

        const groundSize = 15000; 
        const groundGeo = new THREE.PlaneGeometry(groundSize, groundSize, 150, 150);
        groundGeo.rotateX(-Math.PI / 2);

        const vertices = groundGeo.attributes.position.array;
        for (let i = 0; i < vertices.length; i += 3) {
            const x = vertices[i];
            const z = vertices[i + 2];
            vertices[i + 1] = getNoiseHeight(x, z);
        }
        groundGeo.computeVertexNormals();

        const ground = new THREE.Mesh(groundGeo, new THREE.MeshStandardMaterial({ 
            color: isNight ? 0x1a402a : 0x2e8b57, flatShading: true, roughness: 0.8 
        }));
        ground.receiveShadow = true;
        scene.add(ground);

        const water = new THREE.Mesh(
            new THREE.PlaneGeometry(groundSize, groundSize), 
            new THREE.MeshStandardMaterial({ color: 0x1E90FF, transparent: true, opacity: 0.7 })
        );
        water.rotateX(-Math.PI / 2);
        water.position.y = -90;
        scene.add(water);

        function createRunwayMesh() {
            const runwayGroup = new THREE.Group();
            const runwayGeo = new THREE.PlaneGeometry(RUNWAY_WIDTH, RUNWAY_LENGTH);
            const runwayMat = new THREE.MeshPhongMaterial({ color: 0x222222 });
            const runway = new THREE.Mesh(runwayGeo, runwayMat);
            runway.rotation.x = -Math.PI / 2;
            runway.receiveShadow = true;
            runwayGroup.add(runway);

            const stripeGeo = new THREE.PlaneGeometry(2, 40);
            const stripeMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            for(let i=0; i<8; i++) {
                const stripe = new THREE.Mesh(stripeGeo, stripeMat);
                stripe.rotation.x = -Math.PI / 2;
                stripe.position.set(0, 0.1, -(RUNWAY_LENGTH/2 - 50) + (i * 70));
                runwayGroup.add(stripe);
            }
            return runwayGroup;
        }

        runways.forEach(r => {
            const mesh = createRunwayMesh();
            mesh.position.set(r.x, RUNWAY_HEIGHT, r.z);
            mesh.rotation.y = r.rotation;
            scene.add(mesh);
        });

        function createObstacles() {
            const towerGeo = new THREE.BoxGeometry(10, 80, 10);
            const towerMat = new THREE.MeshPhongMaterial({ color: 0x444444 });
            const lightGeo = new THREE.SphereGeometry(1.2, 8, 8);
            const lightMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });

            for(let i=0; i<1000; i++) {
                const tower = new THREE.Mesh(towerGeo, towerMat);
                let tx = (Math.random() - 0.5) * 20000;
                let tz = (Math.random() - 0.5) * 20000;

                let safe = false;
                runways.forEach(r => {
                    const dx = tx - r.x;
                    const dz = tz - r.z;
                    if(dx*dx + dz*dz < 500 * 500) safe = true;
                });

                if(!safe) {
                    tower.position.set(tx, -40, tz); 
                    tower.castShadow = true;
                    tower.receiveShadow = true;
                    
                    // Waarschuwingslampje bovenop de toren
                    const redBulb = new THREE.Mesh(lightGeo, lightMat);
                    redBulb.position.set(0, 40, 0);
                    tower.add(redBulb);
                    
                    scene.add(tower);
                    obstacles.push(tower);
                }
            }
        }
        createObstacles();

        function getGroundHeightAt(x, z) {
            for(let r of runways) {
                const dx = x - r.x;
                const dz = z - r.z;
                const localX = dx * Math.cos(-r.rotation) - dz * Math.sin(-r.rotation);
                const localZ = dx * Math.sin(-r.rotation) + dz * Math.cos(-r.rotation);

                if (Math.abs(localX) < RUNWAY_WIDTH/2 && Math.abs(localZ) < RUNWAY_LENGTH/2) {
                    return RUNWAY_HEIGHT; 
                }
            }
            return getNoiseHeight(x, z);
        }

        function triggerCrash() {
            if(isGameOver) return;
            isGameOver = true;
            airplane.visible = false;
            
            const particleCount = 40;
            const geo = new THREE.BoxGeometry(2, 2, 2);
            const mat = new THREE.MeshBasicMaterial({ color: 0xff4500 });
            for (let i = 0; i < particleCount; i++) {
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(airplane.position);
                mesh.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 4,
                    (Math.random() - 0.5) * 4,
                    (Math.random() - 0.5) * 4
                );
                scene.add(mesh);
                explosionParticles.push(mesh);
            }

            document.getElementById('game-over').style.display = 'block';
            document.getElementById('hud').style.display = 'none';
            document.getElementById('warning-box').style.display = 'none';
            document.getElementById('crosshair').style.display = 'none';

            let timerVal = 5;
            const timerSpan = document.getElementById('restart-timer');
            const countdown = setInterval(() => {
                timerVal--;
                timerSpan.innerText = timerVal;
                if(timerVal <= 0) {
                    clearInterval(countdown);
                    location.reload();
                }
            }, 1000);
        }

        const flightState = {
            speed: 0,
            throttle: 0,
            maxSpeed: 4.8,
            stallSpeed: 0.8,
            lift: 0,
            flaps: 0, 
            rotation: { x: 0, y: 0, z: 0 },
            input: { x: 0, y: 0 },
            keys: { w: false, s: false, a: false, d: false },
            isStalling: false,
            verticalVelocity: 0,
            isParked: true
        };

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        document.addEventListener('mousemove', (e) => {
            if(isGameOver) return;
            // Meer gevoeligheid
            flightState.input.x = (e.clientX / window.innerWidth) * 2 - 1;
            flightState.input.y = (e.clientY / window.innerHeight) * 2 - 1;
        });

        document.addEventListener('keydown', (e) => {
            switch(e.key.toLowerCase()) {
                case 'w': flightState.keys.w = true; break;
                case 's': flightState.keys.s = true; break;
                case 'a': flightState.keys.a = true; break;
                case 'd': flightState.keys.d = true; break;
                case 'f': toggleFlapLevel(); break; 
            }
        });

        document.addEventListener('keyup', (e) => {
            switch(e.key.toLowerCase()) {
                case 'w': flightState.keys.w = false; break;
                case 's': flightState.keys.s = false; break;
                case 'a': flightState.keys.a = false; break;
                case 'd': flightState.keys.d = false; break;
            }
        });

        function toggleFlapLevel() {
            flightState.flaps = (flightState.flaps + 1) % 5;
            const fd = document.getElementById('flaps-display');
            fd.innerText = flightState.flaps;
            if(flightState.flaps === 0) fd.style.color = '#ccc';
            else if(flightState.flaps < 3) fd.style.color = '#ffff00';
            else fd.style.color = '#00ff00';
        }

        function updateHUD() {
            if(isGameOver) return;
            const displaySpeed = Math.floor(flightState.speed * 200); 
            const displayAlt = Math.floor((airplane.position.y - RUNWAY_HEIGHT) * 10);
            
            document.getElementById('speed-display').innerText = displaySpeed;
            document.getElementById('alt-display').innerText = displayAlt;

            if(displayAlt > 50) document.getElementById('ready-display').style.display = 'none';

            const rotDeg = THREE.MathUtils.radToDeg(airplane.rotation.y);
            document.getElementById('compass-arrow').style.transform = `translate(-50%, -50%) rotate(${-rotDeg}deg)`;
            
            let normalizedRot = rotDeg % 360;
            if(normalizedRot < 0) normalizedRot += 360;
            let headingText = "ZUID"; 
            if (normalizedRot > 45 && normalizedRot <= 135) headingText = "OOST"; 
            else if (normalizedRot > 135 && normalizedRot <= 225) headingText = "NOORD";
            else if (normalizedRot > 225 && normalizedRot <= 315) headingText = "WEST";
            document.getElementById('heading-display').innerText = headingText;

            let warningActive = false;
            const wm = document.getElementById('warning-msg');
            if (flightState.isStalling && displayAlt > 100) { 
                wm.innerText = "!! STALL WAARSCHUWING !!";
                wm.style.color = "red";
                warningActive = true;
            } else if (displayAlt > 4000) { 
                wm.innerText = "MAXIMALE HOOGTE BEREIKT";
                wm.style.color = "orange";
                warningActive = true;
            }
            document.getElementById('warning-box').style.display = warningActive ? 'block' : 'none';
        }

        function cameraShake() {
            if (flightState.isStalling && !isGameOver) {
                camera.position.x += (Math.random() - 0.5) * 0.5;
                camera.position.y += (Math.random() - 0.5) * 0.5;
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            if (isGameOver) {
                explosionParticles.forEach(p => {
                    p.position.add(p.userData.velocity);
                    p.rotation.x += 0.1; p.rotation.y += 0.1;
                    p.scale.multiplyScalar(0.95); 
                });
                renderer.render(scene, camera);
                return; 
            }

            // Strobe effect voor staartlicht
            if (airplane.userData.strobe) {
                airplane.userData.strobe.visible = (Math.floor(Date.now() / 200) % 5 === 0);
            }

            let altitudeFactor = Math.max(0, 1 - (airplane.position.y / 400)); 
            
            if (flightState.keys.w) {
                flightState.throttle += 0.01;
                flightState.isParked = false; 
            }
            if (flightState.keys.s) flightState.throttle -= 0.01;
            flightState.throttle = Math.max(0, Math.min(1, flightState.throttle));
            
            let targetSpeed = flightState.throttle * flightState.maxSpeed * altitudeFactor;
            targetSpeed *= (1 - (flightState.flaps * 0.1));
            targetSpeed -= airplane.rotation.x * -2.5; 

            const accelFactor = flightState.speed < 1.0 ? 0.05 : 0.02;
            flightState.speed = THREE.MathUtils.lerp(flightState.speed, targetSpeed, accelFactor);
            if (flightState.speed < 0) flightState.speed = 0;

            let liftCoeff = 0.35 + (flightState.flaps * 0.1);
            let currentStallSpeed = 0.8 - (flightState.flaps * 0.1);

            flightState.lift = (flightState.speed * flightState.speed) * liftCoeff;
            const gravity = 0.8; 
            flightState.isStalling = flightState.speed < currentStallSpeed;

            if (flightState.isParked) {
                flightState.verticalVelocity = 0;
                flightState.speed = 0;
            } else {
                if (flightState.isStalling) {
                    flightState.lift *= 0.2; 
                    airplane.rotation.x += 0.02; 
                }

                let verticalIntent = Math.sin(-airplane.rotation.x) * flightState.speed;
                const currentGroundHeight = getGroundHeightAt(airplane.position.x, airplane.position.z);
                const heightAboveGround = airplane.position.y - currentGroundHeight;

                if (heightAboveGround < PLANE_OFFSET) {
                    const isHardLanding = flightState.verticalVelocity < -1.8;
                    const isBanked = Math.abs(airplane.rotation.z) > 0.6;
                    const isNoseDive = airplane.rotation.x > 0.4; 
                    const isFastEnoughToCrash = flightState.speed > 2.0;

                    if ((isHardLanding || (isBanked && isFastEnoughToCrash) || (isNoseDive && isFastEnoughToCrash))) {
                        triggerCrash();
                    } else {
                        airplane.position.y = currentGroundHeight + PLANE_OFFSET;
                        flightState.verticalVelocity = 0;
                        airplane.rotation.z = THREE.MathUtils.lerp(airplane.rotation.z, 0, 0.1);
                        if(flightState.throttle === 0) flightState.speed *= 0.98;
                        if(flightState.speed > (currentStallSpeed + 0.5)) {
                            flightState.verticalVelocity = 0.25; 
                        }
                    }
                } else {
                    if (flightState.lift < gravity) {
                        flightState.verticalVelocity -= 0.05; 
                    } else {
                        flightState.verticalVelocity = THREE.MathUtils.lerp(flightState.verticalVelocity, verticalIntent, 0.1);
                    }
                }
            }
            if(flightState.verticalVelocity < -2.2) flightState.verticalVelocity = -2.2;

            // Mobiliteit updates
            if (!flightState.isStalling && !flightState.isParked) {
                let targetPitch = flightState.input.y * 1.5; // Verhoogde pitch
                const groundH = getGroundHeightAt(airplane.position.x, airplane.position.z);
                if (airplane.position.y < groundH + PLANE_OFFSET + 2.0) {
                     if (targetPitch > 0) targetPitch = 0;
                     if (flightState.speed > 2.5) if (targetPitch > -0.4) targetPitch = -0.4;
                }
                
                airplane.rotation.x = THREE.MathUtils.lerp(airplane.rotation.x, targetPitch, 0.08); // Snellere lerp
                airplane.rotateY(-flightState.input.x * 0.045); // Verhoogde yaw
                
                let targetRoll = -flightState.input.x * 2.0; // Verhoogde roll
                if (flightState.keys.a) targetRoll = 2.5;
                if (flightState.keys.d) targetRoll = -2.5;
                
                airplane.rotation.z = THREE.MathUtils.lerp(airplane.rotation.z, targetRoll, 0.08); // Snellere lerp
            }

            if(!flightState.isParked) {
                const direction = new THREE.Vector3(0, 0, 1);
                direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), airplane.rotation.y);
                airplane.position.add(direction.multiplyScalar(flightState.speed));
                airplane.position.y += flightState.verticalVelocity;
            } else {
                const currentGroundHeight = getGroundHeightAt(airplane.position.x, airplane.position.z);
                airplane.position.y = currentGroundHeight + PLANE_OFFSET;
            }

            // Obstakel collision check
            const planePos = airplane.position;
            for(let i=0; i<obstacles.length; i++) {
                const tower = obstacles[i];
                const dx = planePos.x - tower.position.x;
                const dz = planePos.z - tower.position.z;
                if (Math.abs(dx) < 15 && Math.abs(dz) < 15 && planePos.y < 40) {
                     triggerCrash();
                     break;
                }
            }

            airplane.userData.propeller.rotation.z += 0.5 + (flightState.speed * 0.6);
            
            const relativeCameraOffset = new THREE.Vector3(0, 8, -25);
            const cameraOffset = relativeCameraOffset.applyMatrix4(airplane.matrixWorld);
            camera.position.lerp(cameraOffset, 0.1);
            cameraShake();
            
            const lookAtPos = new THREE.Vector3(0, 0, 20);
            lookAtPos.applyMatrix4(airplane.matrixWorld);
            camera.lookAt(lookAtPos);

            // Ground/Skybox infinity loop
            const groundLimit = 5000; 
            if (Math.abs(airplane.position.x - ground.position.x) > groundLimit) {
                ground.position.x = airplane.position.x;
                water.position.x = airplane.position.x;
            }
            if (Math.abs(airplane.position.z - ground.position.z) > groundLimit) {
                ground.position.z = airplane.position.z;
                water.position.z = airplane.position.z;
            }

            updateHUD();
            renderer.render(scene, camera);
        }

        animate();
        
        airplane.position.set(0, RUNWAY_HEIGHT + PLANE_OFFSET, -200);
        airplane.rotation.set(0, 0, 0); 
        flightState.speed = 0;
        flightState.throttle = 0;
        flightState.verticalVelocity = 0;
        flightState.isParked = true; 

        setTimeout(() => {
            const instr = document.getElementById('instructions');
            if(instr) instr.style.opacity = 0;
        }, 10000);

    </script>
</body>
</html>