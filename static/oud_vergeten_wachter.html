<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Skelos: De Schaduw Arena</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #050505;
            --ui-color: #a8a8a8;
            --hp-color: #8a1c1c;
            --stamina-color: #2e7d32;
            --boss-hp-color: #590e0e;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--ui-color);
            font-family: 'Cinzel', serif;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            background: radial-gradient(circle, #1a1a1a 0%, #000000 100%);
        }

        /* HUD elements */
        .hud {
            position: absolute;
            pointer-events: none;
        }

        #player-hud {
            top: 20px;
            left: 20px;
            width: 300px;
        }

        .bar-container {
            background: #222;
            border: 1px solid #444;
            height: 15px;
            margin-bottom: 5px;
            position: relative;
        }

        .bar {
            height: 100%;
            transition: width 0.1s linear;
        }

        #hp-bar { background-color: var(--hp-color); width: 100%; box-shadow: 0 0 10px var(--hp-color); }
        #stamina-bar { background-color: var(--stamina-color); width: 100%; }

        #flask-counter {
            margin-top: 10px;
            font-size: 18px;
            color: #e6c65c;
            text-shadow: 0 0 5px #e6c65c;
        }

        #current-weapon {
            margin-top: 5px;
            font-size: 16px;
            color: #ccc;
            transition: color 0.3s;
        }

        /* Boss HUD */
        #boss-hud {
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            width: 60%;
            text-align: center;
            opacity: 0; /* Hidden initially */
            transition: opacity 1s;
        }

        #boss-name {
            font-size: 24px;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: #ccc;
        }

        #boss-hp-bar {
            background-color: var(--boss-hp-color);
            width: 100%;
            box-shadow: 0 0 15px var(--boss-hp-color);
        }

        /* Overlays */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0,0,0,0.85);
            z-index: 10;
            display: none;
        }

        .overlay h1 {
            font-size: 80px;
            margin: 0;
            letter-spacing: 5px;
        }

        #death-screen h1 {
            color: #8a1c1c;
            text-shadow: 0 0 20px #8a1c1c;
            animation: pulse 3s infinite;
        }

        #victory-screen h1 {
            color: #e6c65c;
            text-shadow: 0 0 20px #e6c65c;
        }

        .btn {
            margin-top: 30px;
            padding: 15px 40px;
            background: transparent;
            border: 1px solid #666;
            color: #ccc;
            font-family: 'Cinzel', serif;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn:hover {
            background: #ccc;
            color: #000;
            border-color: #fff;
        }

        #controls-hint {
            position: absolute;
            bottom: 10px;
            right: 10px;
            color: #555;
            font-size: 12px;
            text-align: right;
        }

        @keyframes pulse {
            0% { opacity: 0.8; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.05); }
            100% { opacity: 0.8; transform: scale(1); }
        }
        
        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            10% { transform: translate(-1px, -2px) rotate(-1deg); }
            20% { transform: translate(-3px, 0px) rotate(1deg); }
            30% { transform: translate(3px, 2px) rotate(0deg); }
            40% { transform: translate(1px, -1px) rotate(1deg); }
            50% { transform: translate(-1px, 2px) rotate(-1deg); }
            60% { transform: translate(-3px, 1px) rotate(0deg); }
            70% { transform: translate(3px, 1px) rotate(-1deg); }
            80% { transform: translate(-1px, -1px) rotate(1deg); }
            90% { transform: translate(1px, 2px) rotate(0deg); }
            100% { transform: translate(1px, -2px) rotate(-1deg); }
        }

        .shake-effect {
            animation: shake 0.5s;
        }

    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <!-- Player HUD -->
    <div id="player-hud" class="hud">
        <div class="bar-container"><div id="hp-bar" class="bar"></div></div>
        <div class="bar-container"><div id="stamina-bar" class="bar"></div></div>
        <div id="flask-counter">Estus Flessen: 3</div>
        <div id="current-weapon">Wapen: Oude Stok</div>
    </div>

    <!-- Boss HUD -->
    <div id="boss-hud" class="hud">
        <div id="boss-name">De Vergeten Wachter</div>
        <div class="bar-container" style="height: 20px; border-color: #590e0e;">
            <div id="boss-hp-bar" class="bar"></div>
        </div>
    </div>

    <!-- Controls Hint -->
    <div id="controls-hint">
        WASD: Bewegen | SPATIE: Rollen | MUIS: Aanvallen | E: Genezen
    </div>

    <!-- Death Screen -->
    <div id="death-screen" class="overlay">
        <h1>U BENT GESTORVEN</h1>
        <button class="btn" onclick="game.restart()">Opnieuw Proberen</button>
    </div>

    <!-- Victory Screen -->
    <div id="victory-screen" class="overlay">
        <h1>OVERWINNING BEHAALD</h1>
        <p style="margin-top: 10px; font-size: 18px;">De wachter is gevallen.</p>
        <button class="btn" onclick="game.restart()">Opnieuw Spelen</button>
    </div>
</div>

<script>
    /* --- CONFIGURATIE & SETUP --- */
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // UI Elementen
    const ui = {
        hp: document.getElementById('hp-bar'),
        stamina: document.getElementById('stamina-bar'),
        estus: document.getElementById('flask-counter'),
        weaponName: document.getElementById('current-weapon'),
        bossHud: document.getElementById('boss-hud'),
        bossHp: document.getElementById('boss-hp-bar'),
        death: document.getElementById('death-screen'),
        victory: document.getElementById('victory-screen'),
        container: document.getElementById('game-container')
    };

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // Input Handling
    const keys = {};
    const mouse = { x: 0, y: 0, down: false };

    window.addEventListener('keydown', e => {
        keys[e.code] = true;
        if (e.code === 'KeyE') game.player.heal();
        if (e.code === 'Space') game.player.roll();
    });
    window.addEventListener('keyup', e => keys[e.code] = false);
    window.addEventListener('mousemove', e => {
        mouse.x = e.clientX;
        mouse.y = e.clientY;
    });
    window.addEventListener('mousedown', () => {
        mouse.down = true;
        game.player.attack();
    });
    window.addEventListener('mouseup', () => mouse.down = false);

    /* --- GAME LOGICA --- */

    const WEAPONS = {
        default: { name: "Oude Stok", damage: 15, range: 60, speed: 15, color: '#aaa', width: 4 },
        greatsword: { name: "Vuurzwaard", damage: 45, range: 110, speed: 35, color: '#ff4400', width: 10 },
        dagger: { name: "Schaduw Dolk", damage: 10, range: 40, speed: 5, color: '#a020f0', width: 3 },
        spear: { name: "Donder Speer", damage: 25, range: 140, speed: 20, color: '#00ffff', width: 5 }
    };

    class Pickup {
        constructor(x, y, type) {
            this.x = x;
            this.y = y;
            this.typeKey = type;
            this.data = WEAPONS[type];
            this.radius = 10;
            this.life = 0; // for animation
        }
        
        draw(ctx) {
            this.life += 0.05;
            const floatY = Math.sin(this.life) * 5;
            
            ctx.shadowBlur = 20;
            ctx.shadowColor = this.data.color;
            ctx.fillStyle = this.data.color;
            
            ctx.beginPath();
            ctx.arc(this.x, this.y + floatY, this.radius, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.fillStyle = '#fff';
            ctx.font = '10px Cinzel';
            ctx.textAlign = 'center';
            ctx.fillText("?", this.x, this.y + floatY + 4);
            
            ctx.shadowBlur = 0;
        }
    }

    class Particle {
        constructor(x, y, color, speed, size) {
            this.x = x;
            this.y = y;
            this.color = color;
            const angle = Math.random() * Math.PI * 2;
            const velocity = Math.random() * speed;
            this.vx = Math.cos(angle) * velocity;
            this.vy = Math.sin(angle) * velocity;
            this.life = 1.0;
            this.decay = Math.random() * 0.03 + 0.02;
            this.size = size;
        }
        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.life -= this.decay;
        }
        draw(ctx) {
            ctx.globalAlpha = this.life;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
        }
    }

    class Entity {
        constructor(x, y, radius, color, hp) {
            this.x = x;
            this.y = y;
            this.radius = radius;
            this.color = color;
            this.maxHp = hp;
            this.hp = hp;
            this.dead = false;
            this.invulnerable = false;
        }
        
        takeDamage(amount) {
            if (this.dead || this.invulnerable) return false;
            this.hp -= amount;
            
            // Blood effect
            for(let i=0; i<10; i++) {
                game.particles.push(new Particle(this.x, this.y, '#8a1c1c', 5, 3));
            }

            if (this.hp <= 0) {
                this.hp = 0;
                this.dead = true;
                return true; // Died
            }
            return false; // Hit but alive
        }
    }

    class Player extends Entity {
        constructor() {
            super(canvas.width / 2, canvas.height - 200, 15, '#fff', 100);
            this.maxStamina = 100;
            this.stamina = 100;
            this.staminaRegen = 0.5;
            this.speed = 4;
            this.flasks = 3;
            this.state = 'idle'; // idle, rolling, attacking
            this.angle = 0;
            
            // Weapon Logic
            this.activeWeapon = WEAPONS.default;
            this.weaponTimer = 0; // Frames remaining
            
            this.rollDuration = 20; // frames
            this.rollCooldown = 0;
            this.attackCooldown = 0;
            this.timer = 0;
        }

        equip(key) {
            this.activeWeapon = WEAPONS[key];
            this.weaponTimer = 480; // 8 seconds * 60 fps
            
            ui.weaponName.innerText = `Wapen: ${this.activeWeapon.name} (8s)`;
            ui.weaponName.style.color = this.activeWeapon.color;
            
            // Equip effect
            for(let i=0; i<20; i++) {
                game.particles.push(new Particle(this.x, this.y, this.activeWeapon.color, 4, 3));
            }
        }

        update() {
            if (this.dead) return;

            // Weapon Timer
            if (this.weaponTimer > 0) {
                this.weaponTimer--;
                if (this.weaponTimer % 60 === 0) {
                     ui.weaponName.innerText = `Wapen: ${this.activeWeapon.name} (${Math.ceil(this.weaponTimer/60)}s)`;
                }
                
                if (this.weaponTimer <= 0) {
                    this.activeWeapon = WEAPONS.default;
                    ui.weaponName.innerText = "Wapen: Oude Stok";
                    ui.weaponName.style.color = '#ccc';
                }
            }

            // Stamina Regen
            if (this.state === 'idle' && this.stamina < this.maxStamina) {
                this.stamina += this.staminaRegen;
                if (this.stamina > this.maxStamina) this.stamina = this.maxStamina;
            }

            // Mouse Look
            const dx = mouse.x - this.x;
            const dy = mouse.y - this.y;
            this.angle = Math.atan2(dy, dx);

            // States
            if (this.state === 'rolling') {
                this.timer--;
                this.x += Math.cos(this.rollAngle) * (this.speed * 2);
                this.y += Math.sin(this.rollAngle) * (this.speed * 2);
                
                // Trail effect
                if (this.timer % 3 === 0) {
                    game.particles.push(new Particle(this.x, this.y, '#555', 0, 10));
                }

                if (this.timer <= 0) {
                    this.state = 'idle';
                    this.invulnerable = false;
                    this.rollCooldown = 10;
                }
            } else if (this.state === 'attacking') {
                this.timer--;
                if (this.timer <= 0) {
                    this.state = 'idle';
                    this.attackCooldown = 15;
                }
            } else {
                // Movement
                let moveX = 0;
                let moveY = 0;
                if (keys['KeyW']) moveY = -1;
                if (keys['KeyS']) moveY = 1;
                if (keys['KeyA']) moveX = -1;
                if (keys['KeyD']) moveX = 1;

                if (moveX !== 0 || moveY !== 0) {
                    // Normalize vector
                    const len = Math.sqrt(moveX*moveX + moveY*moveY);
                    moveX /= len;
                    moveY /= len;
                    this.x += moveX * this.speed;
                    this.y += moveY * this.speed;
                }

                // Cooldowns
                if (this.rollCooldown > 0) this.rollCooldown--;
                if (this.attackCooldown > 0) this.attackCooldown--;
            }

            // Boundaries
            this.x = Math.max(20, Math.min(canvas.width - 20, this.x));
            this.y = Math.max(20, Math.min(canvas.height - 20, this.y));
        }

        draw(ctx) {
            if (this.dead) return;

            ctx.save();
            ctx.translate(this.x, this.y);
            
            // Draw Player Body
            ctx.shadowBlur = 10;
            ctx.shadowColor = this.invulnerable ? '#fff' : 'rgba(0,0,0,0)';
            ctx.fillStyle = this.state === 'rolling' ? '#888' : this.color;
            ctx.beginPath();
            ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw Weapon Indicator
            if (this.state !== 'rolling') {
                ctx.rotate(this.angle);
                
                // Weapon visual
                if (this.state === 'attacking') {
                    ctx.fillStyle = this.activeWeapon.color;
                    ctx.shadowColor = this.activeWeapon.color;
                    ctx.shadowBlur = 20;
                    
                    // Swing animation
                    const progress = 1 - (this.timer / this.activeWeapon.speed); // 0 to 1
                    const swingArc = Math.PI / 2; // 90 degrees
                    const startAngle = -swingArc / 2;
                    const currentAngle = startAngle + (swingArc * progress);
                    
                    ctx.rotate(currentAngle);
                    ctx.fillRect(0, -this.activeWeapon.width/2, this.activeWeapon.range, this.activeWeapon.width);
                    
                    // Hitbox logic (only once per swing, simplistically checked every frame but gated by enemies iframe)
                    // Check collision with boss
                    const tipX = this.x + Math.cos(this.angle + currentAngle) * this.activeWeapon.range;
                    const tipY = this.y + Math.sin(this.angle + currentAngle) * this.activeWeapon.range;
                    
                    if (!game.boss.dead && !game.boss.invulnerable) {
                        const dist = Math.hypot(tipX - game.boss.x, tipY - game.boss.y);
                        if (dist < game.boss.radius + 30) { // Slight generous hit detection
                            game.boss.takeDamage(this.activeWeapon.damage); // Player Damage
                            game.shake(5);
                            game.boss.invulnerable = true;
                            setTimeout(() => game.boss.invulnerable = false, Math.max(200, this.activeWeapon.speed * 10));
                        }
                    }

                } else {
                    // Static weapon holding
                    ctx.fillStyle = this.activeWeapon.color;
                    ctx.shadowBlur = 0;
                    ctx.fillRect(10, -2, 30, 4);
                }
            }

            ctx.restore();
        }

        roll() {
            if (this.state !== 'idle' || this.stamina < 25 || this.rollCooldown > 0) return;
            
            this.stamina -= 25;
            this.state = 'rolling';
            this.invulnerable = true;
            this.timer = this.rollDuration;
            
            // Roll direction: movement keys or facing mouse
            let moveX = 0;
            let moveY = 0;
            if (keys['KeyW']) moveY = -1;
            if (keys['KeyS']) moveY = 1;
            if (keys['KeyA']) moveX = -1;
            if (keys['KeyD']) moveX = 1;

            if (moveX === 0 && moveY === 0) {
                this.rollAngle = this.angle; // Roll towards mouse if standing still
            } else {
                this.rollAngle = Math.atan2(moveY, moveX);
            }
        }

        attack() {
            if (this.state !== 'idle' || this.stamina < 20 || this.attackCooldown > 0) return;
            
            this.stamina -= 20;
            this.state = 'attacking';
            this.timer = this.activeWeapon.speed;
        }

        heal() {
            if (this.dead || this.state !== 'idle' || this.flasks <= 0 || this.hp >= this.maxHp) return;
            
            this.flasks--;
            this.hp = Math.min(this.hp + 50, this.maxHp);
            ui.estus.innerText = `Estus Flessen: ${this.flasks}`;
            
            // Heal effect
            for(let i=0; i<15; i++) {
                game.particles.push(new Particle(this.x, this.y, '#e6c65c', 3, 2));
            }
        }
    }

    class Boss extends Entity {
        constructor() {
            super(canvas.width / 2, canvas.height / 2, 40, '#590e0e', 1000);
            this.speed = 2;
            this.state = 'idle'; // idle, chase, telegraph, attack, recover
            this.timer = 0;
            this.phase = 1;
            this.attackType = 0;
        }

        update(player) {
            if (this.dead) return;

            const distToPlayer = Math.hypot(player.x - this.x, player.y - this.y);

            // AI State Machine
            if (this.state === 'idle') {
                this.timer++;
                if (this.timer > 30) {
                    this.state = 'chase';
                    this.timer = 0;
                }
            }
            else if (this.state === 'chase') {
                const angle = Math.atan2(player.y - this.y, player.x - this.x);
                this.x += Math.cos(angle) * this.speed;
                this.y += Math.sin(angle) * this.speed;

                if (distToPlayer < 150) {
                    this.state = 'telegraph';
                    this.timer = 0;
                    // Phase 2 faster attacks
                    this.attackMaxTime = this.hp < this.maxHp/2 ? 30 : 50; 
                    this.attackType = Math.random() > 0.5 ? 0 : 1; // 0 = slash, 1 = smash
                }
            }
            else if (this.state === 'telegraph') {
                this.timer++;
                // Stop moving, charge up
                if (this.timer > this.attackMaxTime) {
                    this.state = 'attack';
                    this.timer = 0;
                }
            }
            else if (this.state === 'attack') {
                this.timer++;
                
                // Perform Attack Logic frame 1
                if (this.timer === 1) {
                    if (this.attackType === 0) { // Spin Slash
                        if (distToPlayer < 160 && !player.invulnerable) {
                            player.takeDamage(35);
                            game.shake(10);
                        }
                        // Visuals for slash
                        for(let i=0; i<20; i++) game.particles.push(new Particle(this.x, this.y, '#fff', 10, 2));
                    } else { // Smash
                         if (distToPlayer < 180 && !player.invulnerable) {
                            player.takeDamage(50);
                            game.shake(20);
                        }
                         // Visuals for smash
                         for(let i=0; i<30; i++) game.particles.push(new Particle(this.x, this.y, '#ff4444', 12, 3));
                    }
                }

                if (this.timer > 20) {
                    this.state = 'recover';
                    this.timer = 0;
                }
            }
            else if (this.state === 'recover') {
                this.timer++;
                const recoveryTime = this.hp < this.maxHp/2 ? 40 : 80;
                if (this.timer > recoveryTime) {
                    this.state = 'idle';
                    this.timer = 0;
                }
            }

            // Phase 2 Enrage Color
            if (this.hp < this.maxHp / 2 && this.phase === 1) {
                this.phase = 2;
                this.color = '#ff0000'; // Enraged color
                // Shockwave
                game.shake(30);
                for(let i=0; i<50; i++) game.particles.push(new Particle(this.x, this.y, '#ff0000', 8, 4));
            }
        }

        draw(ctx) {
            if (this.dead) return;

            ctx.save();
            ctx.translate(this.x, this.y);

            // Boss Glow
            ctx.shadowBlur = 30;
            ctx.shadowColor = this.color;
            
            // Telegraph indicator
            if (this.state === 'telegraph') {
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = (this.timer / this.attackMaxTime) * 5;
                ctx.beginPath();
                // Draw range circle
                const range = this.attackType === 0 ? 160 : 180;
                ctx.arc(0, 0, range, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.fillStyle = `rgba(255, 255, 255, ${this.timer/this.attackMaxTime * 0.5})`;
                ctx.fill();
            }

            // Body
            ctx.fillStyle = this.color;
            ctx.beginPath();
            // Draw a slightly "spiky" shape for boss
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2 + (Date.now() / 1000);
                const r = this.radius + Math.sin(angle * 3) * 5;
                ctx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
            }
            ctx.closePath();
            ctx.fill();

            // Eyes
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(-15, -10, 5, 0, Math.PI*2);
            ctx.arc(15, -10, 5, 0, Math.PI*2);
            ctx.fill();

            ctx.restore();
        }
    }

    class Game {
        constructor() {
            this.particles = [];
            this.pickups = [];
            this.shakeTimer = 0;
            this.active = false;
            this.pickupTimer = 0;
        }

        init() {
            this.player = new Player();
            this.boss = new Boss();
            this.pickups = [];
            this.active = true;
            ui.death.style.display = 'none';
            ui.victory.style.display = 'none';
            ui.bossHud.style.opacity = '1';
            ui.estus.innerText = "Estus Flessen: 3";
            ui.container.classList.remove('shake-effect');
            
            this.loop();
        }

        restart() {
            this.init();
        }

        shake(duration) {
            ui.container.classList.remove('shake-effect');
            void ui.container.offsetWidth; // trigger reflow
            ui.container.classList.add('shake-effect');
        }

        loop() {
            if (!this.active) return;

            // Spawn Pickups (Every 10 seconds approx)
            this.pickupTimer++;
            if (this.pickupTimer > 600) { // 600 frames = 10s
                this.pickupTimer = 0;
                if (this.pickups.length < 3) {
                    const types = ['greatsword', 'dagger', 'spear'];
                    const type = types[Math.floor(Math.random() * types.length)];
                    // Random position, but away from edges
                    const px = 100 + Math.random() * (canvas.width - 200);
                    const py = 100 + Math.random() * (canvas.height - 200);
                    this.pickups.push(new Pickup(px, py, type));
                }
            }

            // Clear
            ctx.fillStyle = 'rgba(5, 5, 5, 0.3)'; // Trail effect
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Updates
            this.player.update();
            if (!this.player.dead) {
                this.boss.update(this.player);
            }

            // Check Pickup Collisions
            for (let i = this.pickups.length - 1; i >= 0; i--) {
                const p = this.pickups[i];
                const dist = Math.hypot(this.player.x - p.x, this.player.y - p.y);
                if (dist < this.player.radius + p.radius) {
                    this.player.equip(p.typeKey);
                    this.pickups.splice(i, 1);
                }
            }

            // Particles
            for (let i = this.particles.length - 1; i >= 0; i--) {
                const p = this.particles[i];
                p.update();
                p.draw(ctx);
                if (p.life <= 0) this.particles.splice(i, 1);
            }

            // Draw Entities
            // Draw Pickups
            this.pickups.forEach(p => p.draw(ctx));
            
            this.boss.draw(ctx);
            this.player.draw(ctx);

            // UI Updates
            ui.hp.style.width = (this.player.hp / this.player.maxHp * 100) + '%';
            ui.stamina.style.width = (this.player.stamina / this.player.maxStamina * 100) + '%';
            ui.bossHp.style.width = (this.boss.hp / this.boss.maxHp * 100) + '%';

            // Game Over Check
            if (this.player.dead) {
                this.active = false;
                setTimeout(() => ui.death.style.display = 'flex', 1000);
            }
            // Victory Check
            if (this.boss.dead) {
                this.active = false;
                // Explosion of particles
                for(let i=0; i<100; i++) this.particles.push(new Particle(this.boss.x, this.boss.y, '#fff', 10, 5));
                setTimeout(() => ui.victory.style.display = 'flex', 2000);
            }

            requestAnimationFrame(() => this.loop());
        }
    }

    const game = new Game();
    game.init();

</script>
</body>
</html>