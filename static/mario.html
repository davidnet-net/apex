<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Mario - Multiplayer & Seeded Levels</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #5c94fc; font-family: 'Segoe UI', sans-serif; user-select: none; }
        #stats-container { position: absolute; top: 20px; right: 20px; display: flex; flex-direction: column; gap: 10px; align-items: flex-end; pointer-events: none; z-index: 10; }
        .stat-box { background: rgba(0, 0, 0, 0.6); backdrop-filter: blur(5px); padding: 8px 15px; border-radius: 20px; color: white; font-weight: bold; font-size: 16px; display: flex; align-items: center; gap: 10px; border: 1px solid rgba(255,255,255,0.1); box-shadow: 0 4px 6px rgba(0,0,0,0.2); }
        .heart-icon { color: #ff4444; font-size: 20px; }
        .star-icon { color: #ffd700; font-size: 20px; }
        .score-icon { color: #4caf50; font-size: 20px; }
        .fps-icon { color: #00ffff; font-size: 20px; }
        #settings-btn { position: absolute; top: 20px; left: 20px; cursor: pointer; font-size: 24px; background: rgba(0,0,0,0.6); color: white; border-radius: 50%; width: 45px; height: 45px; display: flex; align-items: center; justify-content: center; z-index: 11; border: 1px solid rgba(255,255,255,0.1); }
        #settings-menu { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(20, 20, 40, 0.95); color: white; padding: 30px; border-radius: 15px; border: 2px solid #5c94fc; z-index: 100; width: 300px; text-align: center; }
        .setting-row { margin-bottom: 20px; text-align: left; }
        label { display: block; margin-bottom: 5px; font-weight: bold; color: #88ccff; }
        input[type=range], input[type=text] { width: 100%; box-sizing: border-box; }
        .val-display { float: right; color: #f8b800; }
        #instructions { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.7); color: white; padding: 10px 25px; border-radius: 30px; font-size: 14px; text-align: center; }
        #game-over { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.9); color: white; padding: 40px; border-radius: 20px; text-align: center; display: none; border: 4px solid gold; z-index: 20; }
        button.menu-btn { background: linear-gradient(to bottom, #f8b800, #d49000); border: none; padding: 12px 30px; font-size: 18px; font-weight: bold; cursor: pointer; border-radius: 8px; margin-top: 20px; color: #333; }
        #powerup-msg, #checkpoint-msg { display: none; color: #ffff00; font-size: 30px; font-weight: bold; position: absolute; top: 20%; left: 50%; transform: translate(-50%, -50%); text-shadow: 2px 2px 0px #000; animation: popUp 1s forwards; pointer-events: none; z-index: 20; }
        @keyframes popUp { 0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; } 100% { transform: translate(-50%, -150%) scale(1); opacity: 0; } }
    </style>
</head>
<body>

    <button id="settings-btn" onclick="openSettings()">‚öôÔ∏è</button>

    <div id="stats-container">
        <div class="stat-box"><span class="fps-icon">‚ö°</span> <span id="fps-counter">60</span> FPS</div>
        <div class="stat-box"><span class="heart-icon">‚ù§Ô∏è</span> <span id="lives">3</span></div>
        <div class="stat-box"><span class="star-icon">‚≠ê</span> <span id="stars">0</span> / <span id="total-stars">0</span></div>
        <div class="stat-box"><span class="score-icon">üèÜ</span> <span id="score">0</span></div>
    </div>
    
    <div id="powerup-msg">POWER UP!</div>
    <div id="checkpoint-msg">CHECKPOINT!</div>

    <div id="settings-menu">
        <h2 style="color: gold;">Instellingen</h2>
        <div class="setting-row">
            <label>Spelernaam</label>
            <input type="text" id="opt-name" placeholder="Mario" onchange="updateSettingsUI()">
        </div>
        <div class="setting-row">
            <label>Level Lengte <span id="val-len" class="val-display">8</span></label>
            <input type="range" id="opt-length" min="4" max="20" step="1" value="8" oninput="updateSettingsUI()">
        </div>
        <div class="setting-row">
            <label>Max FPS <span id="val-fps" class="val-display">60</span></label>
            <input type="range" id="opt-fps" min="30" max="144" step="30" value="60" oninput="updateSettingsUI()">
        </div>
        <button class="menu-btn" onclick="closeSettings()">Opslaan & Sluiten</button>
    </div>

    <div id="instructions"><b>WASD</b> lopen | <b>Spatie</b> springen | <b>F</b> vuurbal | <b>Muis</b> kijken</div>

    <div id="game-over">
        <h1 id="status-text">GEWONNEN!</h1>
        <p id="end-msg">Je hebt de vlag bereikt!</p>
        <button class="menu-btn" onclick="restartGame(true)">Opnieuw Spelen</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- MULTIPLAYER & SEED LOGICA ---
        class MultiplayerManager {
            constructor(scene) {
                this.scene = scene;
                this.id = 'p_' + Math.random().toString(36).substr(2, 9);
                this.name = "Mario";
                this.ghosts = new Map();
                this.currentSeed = null;
                this.syncCounter = 0;
            }

            // Seeded Random Generator (LCG) zodat het level voor iedereen gelijk is
            seededRandom(seed) {
                let m = 0x80000000, a = 1103515245, c = 12345;
                let state = seed;
                return () => {
                    state = (a * state + c) % m;
                    return state / (m - 1);
                };
            }

            async sync() {
                this.syncCounter++;
                if (this.syncCounter % 5 !== 0) return; // Sync op ~12Hz

                try {
                    const res = await fetch('/api/mario', {
                        method: 'POST',
                        body: JSON.stringify({
                            action: 'update',
                            id: this.id,
                            payload: {
                                name: this.name,
                                x: player.position.x, y: player.position.y, z: player.position.z,
                                rot: player.rotation.y, isBig, hasFirePower
                            }
                        })
                    });
                    const data = await res.json();
                    this.processState(data.gameState);
                    this.updateGhosts(data.players);
                } catch(e) {}
            }

            processState(state) {
                lives = state.sharedLives;
                score = state.sharedScore;
                starsCollected = state.sharedStars;
                document.getElementById('lives').innerText = lives;
                document.getElementById('score').innerText = score;
                document.getElementById('stars').innerText = starsCollected;

                if (this.currentSeed !== null && this.currentSeed !== state.levelSeed) {
                    this.currentSeed = state.levelSeed;
                    restartGame(true);
                }
                this.currentSeed = state.levelSeed;
            }

            updateGhosts(players) {
                const activeIds = new Set(players.map(p => p.id));
                for (let [id, mesh] of this.ghosts.entries()) {
                    if (!activeIds.has(id)) { this.scene.remove(mesh); this.ghosts.delete(id); }
                }

                players.forEach(p => {
                    let ghost = this.ghosts.get(p.id);
                    if (!ghost) {
                        ghost = this.createGhostMesh();
                        this.scene.add(ghost);
                        this.ghosts.set(p.id, ghost);
                    }
                    ghost.position.lerp(new THREE.Vector3(p.x, p.y, p.z), 0.2);
                    ghost.rotation.y = p.rot;
                    const s = p.isBig ? 1.5 : 1;
                    ghost.scale.set(s,s,s);
                    this.updateNameTag(ghost, p.name);
                });
            }

            createGhostMesh() {
                const group = new THREE.Group();
                const body = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshStandardMaterial({color: 0x0088ff, transparent: true, opacity: 0.7}));
                group.add(body);
                return group;
            }

            updateNameTag(group, name) {
                let tag = group.getObjectByName('nametag');
                if (!tag || tag.userData.name !== name) {
                    if (tag) group.remove(tag);
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = 256; canvas.height = 64;
                    ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(0,0,256,64);
                    ctx.font = 'bold 40px Arial'; ctx.fillStyle = 'white'; ctx.textAlign = 'center';
                    ctx.fillText(name, 128, 48);
                    const tex = new THREE.CanvasTexture(canvas);
                    const sprite = new THREE.Sprite(new THREE.SpriteMaterial({map: tex}));
                    sprite.name = 'nametag'; sprite.userData.name = name;
                    sprite.position.y = 1.8; sprite.scale.set(2, 0.5, 1);
                    group.add(sprite);
                }
            }
        }

        // --- ORIGINELE CONFIGURATIE ---
        let gameConfig = { levelLength: 8, sensitivity: 0.002, maxFPS: 60 };
        let fpsInterval, now, then, elapsed, frameCount = 0, lastTimeFPS = 0;
        let scene, camera, renderer, player, clock, mp;
        let platforms = [], movingPlatforms = [], stars = [], goombas = [], thwomps = [], bulletBills = [], bullets = [], particles = [], powerups = [], projectiles = [], clouds = [], checkpoints = []; 
        let flag = null, score = 0, starsCollected = 0, totalStarsInLevel = 0, isGameOver = false, isPaused = false;
        let lives = 3, currentCheckpoint = { x: 0, y: 5, z: 0, rot: Math.PI }, isBig = false, hasFirePower = false, isImmune = false; 
        const keys = {};
        const gravity = -0.015, acceleration = 0.025, friction = 0.85, maxSpeed = 0.35;
        let velocityX = 0, velocityZ = 0, velocityY = 0, jumpCount = 0, targetRotationY = Math.PI, targetRotationX = 0.4;
        const textures = {};

        function generateTextures() {
            const getCtx = (w, h) => { const c = document.createElement('canvas'); c.width = w; c.height = h; return {c, ctx: c.getContext('2d')}; };
            let t = getCtx(256, 256); t.ctx.fillStyle = '#2e7d32'; t.ctx.fillRect(0,0,256,256);
            for(let i=0; i<3000; i++) { t.ctx.fillStyle = Math.random() > 0.5 ? '#4caf50' : '#1b5e20'; t.ctx.fillRect(Math.random()*256, Math.random()*256, 4, 4); }
            textures['grass'] = new THREE.CanvasTexture(t.c); textures['grass'].wrapS = textures['grass'].wrapT = THREE.RepeatWrapping;
            t = getCtx(256, 256); t.ctx.fillStyle = '#bf360c'; t.ctx.fillRect(0,0,256,256);
            textures['brick'] = new THREE.CanvasTexture(t.c); textures['brick'].wrapS = textures['brick'].wrapT = THREE.RepeatWrapping;
            t = getCtx(256, 256); t.ctx.fillStyle = '#757575'; t.ctx.fillRect(0,0,256,256);
            textures['stone'] = new THREE.CanvasTexture(t.c); textures['stone'].wrapS = textures['stone'].wrapT = THREE.RepeatWrapping;
            t = getCtx(256, 256); t.ctx.fillStyle = '#6d4c41'; t.ctx.fillRect(0,0,256,256);
            textures['wood'] = new THREE.CanvasTexture(t.c); textures['wood'].wrapS = textures['wood'].wrapT = THREE.RepeatWrapping;
            t = getCtx(128, 128); t.ctx.fillStyle = '#ffd700'; t.ctx.fillRect(0,0,128,128);
            textures['gold'] = new THREE.CanvasTexture(t.c);
        }

        function updateSettingsUI() {
            document.getElementById('val-len').innerText = document.getElementById('opt-length').value;
            document.getElementById('val-fps').innerText = document.getElementById('opt-fps').value;
            if (mp) mp.name = document.getElementById('opt-name').value || "Mario";
        }

        function openSettings() { isPaused = true; document.exitPointerLock(); document.getElementById('settings-menu').style.display = 'block'; }
        function closeSettings() {
            let oldLen = gameConfig.levelLength;
            gameConfig.levelLength = parseInt(document.getElementById('opt-length').value);
            gameConfig.maxFPS = parseInt(document.getElementById('opt-fps').value);
            fpsInterval = 1000 / gameConfig.maxFPS;
            document.getElementById('settings-menu').style.display = 'none';
            isPaused = false; renderer.domElement.requestPointerLock();
            if (oldLen !== gameConfig.levelLength) restartGame(true);
        }

        function init() {
            generateTextures();
            scene = new THREE.Scene(); scene.background = new THREE.Color(0x6fa8ff);
            scene.fog = new THREE.Fog(0x6fa8ff, 20, 150);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; document.body.appendChild(renderer.domElement);
            clock = new THREE.Clock();

            scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.7));
            const dl = new THREE.DirectionalLight(0xffffff, 1.2); dl.position.set(50,80,50); dl.castShadow = true; scene.add(dl);

            mp = new MultiplayerManager(scene);
            createPlayer(); createClouds(); 

            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', e => keys[e.code] = false);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('click', () => { if(!isPaused && !isGameOver) renderer.domElement.requestPointerLock(); });

            fpsInterval = 1000 / gameConfig.maxFPS;
            then = Date.now(); lastTimeFPS = performance.now();
            animate();
        }

        function onKeyDown(e) {
            if (isGameOver || isPaused) return;
            keys[e.code] = true;
            if (e.code === 'Space' && jumpCount < 2) { velocityY = 0.42; jumpCount++; currentPlatform = null; }
            if (e.code === 'KeyF' && hasFirePower) shootFireball();
        }

        function clearWorld() {
            platforms.forEach(p => scene.remove(p.mesh)); platforms = []; movingPlatforms = [];
            stars.forEach(s => scene.remove(s)); stars = []; totalStarsInLevel = 0;
            goombas.forEach(g => scene.remove(g.mesh)); goombas = [];
            thwomps.forEach(t => scene.remove(t.mesh)); thwomps = [];
            bulletBills.forEach(b => scene.remove(b.mesh)); bulletBills = [];
            bullets.forEach(b => scene.remove(b.mesh)); bullets = [];
            powerups.forEach(p => scene.remove(p.mesh)); powerups = [];
            projectiles.forEach(p => scene.remove(p.mesh)); projectiles = [];
            particles.forEach(p => scene.remove(p)); particles = [];
            checkpoints.forEach(cp => scene.remove(cp.mesh)); checkpoints = []; 
            if (flag) { scene.remove(flag); flag = null; }
        }

        // --- LEVEL GENERATOR MET SEED ---
        function generateLevel() {
            clearWorld();
            const rng = mp.seededRandom(mp.currentSeed || 12345);
            createPlatform(0, 0, 0, 8, 1, 8, 'grass', 'box');

            let currentX = 0, currentY = 0, currentZ = 0, currentAngle = -Math.PI; 
            const availableBuildings = [
                { type: 'tower' }, { type: 'spiral' }, { type: 'ruins' }, { type: 'castle' },
                { type: 'skyFortress' }, { type: 'clockTower' }, { type: 'twinTowers' }, { type: 'colosseum' },
                { type: 'lighthouse' }, { type: 'windmill' }, { type: 'greenhouse' },
                { type: 'well' }, { type: 'shrine' }, { type: 'gazebo' }
            ];

            for (let s = 0; s < gameConfig.levelLength; s++) {
                const seg = availableBuildings[Math.floor(rng() * availableBuildings.length)];
                for(let i=0; i<5; i++) {
                    currentAngle += (rng() - 0.5) * 0.8;
                    let dist = 5 + rng() * 2;
                    currentX += Math.sin(currentAngle) * dist; currentZ += Math.cos(currentAngle) * dist;
                    currentY += (rng() * 2.5) - 0.5;
                    createPlatform(currentX, currentY, currentZ, 4, 1, 4, rng() > 0.8 ? 'wood' : 'grass', 'box');
                    if (rng() < 0.2) createPowerup(currentX, currentY + 1, currentZ, rng() > 0.5 ? 'mushroom' : 'flower', rng);
                    else if (rng() < 0.3) addStar(currentX, currentY + 1.5, currentZ);
                }
                
                let bX = currentX + Math.sin(currentAngle) * 10, bZ = currentZ + Math.cos(currentAngle) * 10;
                let exit;
                switch(seg.type) {
                    case 'tower': exit = createBuildingTower(bX, currentY, bZ); break;
                    case 'spiral': exit = createSpiralStaircase(bX, currentY, bZ); break;
                    case 'ruins': exit = createFloatingRuins(bX, currentY, bZ, rng); break;
                    case 'castle': exit = createBuildingCastle(bX, currentY, bZ); break;
                    case 'skyFortress': exit = createSkyFortress(bX, currentY, bZ); break;
                    case 'clockTower': exit = createClockTower(bX, currentY, bZ); break;
                    case 'twinTowers': exit = createTwinTowers(bX, currentY, bZ); break;
                    case 'colosseum': exit = createColosseum(bX, currentY, bZ); break;
                    case 'lighthouse': exit = createLighthouse(bX, currentY, bZ); break;
                    case 'windmill': exit = createWindmill(bX, currentY, bZ); break;
                    case 'greenhouse': exit = createGreenhouse(bX, currentY, bZ); break;
                    case 'well': exit = createWell(bX, currentY, bZ); break;
                    case 'shrine': exit = createShrine(bX, currentY, bZ); break;
                    case 'gazebo': exit = createGazebo(bX, currentY, bZ); break;
                }
                createCheckpoint(exit.x, exit.y, exit.z);
                currentX = exit.x; currentY = exit.y; currentZ = exit.z;
            }
            createPlatform(currentX + 10, currentY, currentZ, 6, 1, 6, 'gold', 'box');
            createFlag(currentX + 10, currentY + 0.5, currentZ);
            document.getElementById('total-stars').innerText = totalStarsInLevel;
        }

        // --- GEBOUWEN FUNCTIES ---
        function createSkyFortress(x, y, z) {
            createPlatform(x, y, z, 20, 2, 20, 'stone', 'box');
            createPlatform(x, y+5, z, 10, 8, 10, 'brick', 'box');
            createThwomp(x, y+15, z);
            return { x, y: y+9, z: z+12 };
        }
        function createClockTower(x, y, z) {
            createPlatform(x, y, z, 8, 1, 8, 'brick', 'box');
            createPlatform(x, y+10, z, 4, 20, 4, 'brick', 'box');
            createBulletBill(x, y+2, z+5, Math.PI);
            return { x, y, z: z+6 };
        }
        function createTwinTowers(x, y, z) {
            createPlatform(x-5, y+6, z, 4, 12, 4, 'stone', 'box');
            createPlatform(x+5, y+6, z, 4, 12, 4, 'stone', 'box');
            createPlatform(x, y+10, z, 8, 1, 3, 'wood', 'box');
            return { x, y: y+10, z };
        }
        function createColosseum(x, y, z) {
            createPlatform(x, y, z, 16, 1, 16, 'stone', 'box');
            createThwomp(x, y+5, z);
            return { x, y, z: z+9 };
        }
        function createLighthouse(x, y, z) {
            createPlatform(x, y, z, 6, 1, 6, 'stone', 'box');
            createPlatform(x, y+11, z, 3, 1, 3, 'gold', 'box');
            return { x, y, z: z+5 };
        }
        function createWindmill(x, y, z) {
            createPlatform(x, y, z, 6, 1, 6, 'grass', 'box');
            return { x, y, z: z+5 };
        }
        function createGreenhouse(x, y, z) {
            createPlatform(x, y, z, 8, 1, 8, 'grass', 'box');
            return { x, y, z: z+6 };
        }
        function createWell(x, y, z) {
            createPlatform(x, y, z, 5, 1, 5, 'stone', 'box');
            return { x, y, z: z+4 };
        }
        function createShrine(x, y, z) {
            createPlatform(x, y, z, 5, 1, 5, 'stone', 'box');
            addStar(x, y+1, z);
            return { x, y, z: z+4 };
        }
        function createGazebo(x, y, z) {
            createPlatform(x, y, z, 5, 0.5, 5, 'wood', 'cylinder');
            return { x, y, z: z+4 };
        }
        function createFloatingRuins(x, y, z, rng) {
            for(let i=0; i<10; i++) {
                createPlatform(x+(rng()-0.5)*10, y+rng()*5, z+(rng()-0.5)*10, 3, 1, 3, 'stone', 'box');
            }
            return { x, y, z: z+8 };
        }
        function createSpiralStaircase(x, y, z) {
            createPlatform(x, y, z, 8, 1, 8, 'stone', 'box');
            return { x, y, z };
        }
        function createBuildingTower(x, y, z) {
            createPlatform(x, y, z, 14, 1, 14, 'stone', 'box');
            return { x, y: y+10, z };
        }
        function createBuildingCastle(x, y, z) {
            createPlatform(x, y, z, 10, 1, 16, 'stone', 'box');
            createThwomp(x, y+5, z);
            return { x, y, z: z+9 };
        }

        // --- HULPFUNCTIES (PLATFORMS, VIJANDEN, ETC) ---
        function createPlatform(x, y, z, w, h, d, type, shape) {
            const geo = shape === 'box' ? new THREE.BoxGeometry(w, h, d) : new THREE.CylinderGeometry(w/2, w/2, h, 32);
            const mat = new THREE.MeshStandardMaterial({ map: textures[type] || null, color: textures[type] ? 0xffffff : type });
            const mesh = new THREE.Mesh(geo, mat); mesh.position.set(x, y, z); mesh.receiveShadow = true; mesh.castShadow = true;
            scene.add(mesh); platforms.push({ mesh, w, h, d });
        }

        function createCheckpoint(x, y, z) {
            const group = new THREE.Group();
            createPlatform(x, y-0.5, z, 3, 1, 3, 'stone', 'box');
            const flagMesh = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.6, 0.05), new THREE.MeshStandardMaterial({ color: 0x00FF00 }));
            flagMesh.position.set(0.4, 1.6, 0); group.add(flagMesh);
            group.position.set(x, y, z); scene.add(group);
            checkpoints.push({ mesh: group, flagMesh, active: false, pos: {x, y: y+1, z} });
        }

        function createFlag(x, y, z) {
            flag = new THREE.Group();
            const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 4), new THREE.MeshStandardMaterial({ color: 0x888888 }));
            pole.position.y = 2; flag.add(pole);
            const sail = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1, 0.1), new THREE.MeshStandardMaterial({ color: 0x00ff00 }));
            sail.position.set(0.75, 3.5, 0); flag.add(sail);
            flag.position.set(x, y, z); scene.add(flag);
        }

        function addStar(x, y, z) {
            const s = new THREE.Mesh(new THREE.OctahedronGeometry(0.4), new THREE.MeshStandardMaterial({ color: 0xffd700, emissive: 0xaa6600 }));
            s.position.set(x, y, z); scene.add(s); stars.push(s); totalStarsInLevel++;
        }

        function createGoomba(x, y, z, w, d) {
            const g = new THREE.Group();
            g.add(new THREE.Mesh(new THREE.BoxGeometry(0.8,0.8,0.8), new THREE.MeshStandardMaterial({color: 0x8B4513})));
            g.position.set(x,y,z); scene.add(g);
            goombas.push({ mesh: g, startX: x, limit: w/2 - 0.5, dir: 1, speed: 0.04 });
        }

        function createThwomp(x, y, z) {
            const g = new THREE.Group();
            g.add(new THREE.Mesh(new THREE.BoxGeometry(2, 2.5, 2), new THREE.MeshStandardMaterial({color: 0x777777})));
            g.position.set(x,y,z); scene.add(g);
            thwomps.push({ mesh: g, homeY: y, state: 'IDLE', timer: 0 });
        }

        function createBulletBill(x, y, z, ang) {
            const b = new THREE.Mesh(new THREE.BoxGeometry(1.5,1.5,1.5), new THREE.MeshStandardMaterial({color: 0x111111}));
            b.position.set(x,y,z); scene.add(b);
            bulletBills.push({ mesh: b, interval: 150, timer: 0, ang });
        }

        function createPlayer() {
            player = new THREE.Group();
            player.add(new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), new THREE.MeshStandardMaterial({ color: 0xff0000 })));
            const p = new THREE.Mesh(new THREE.BoxGeometry(1.02, 0.4, 1.02), new THREE.MeshStandardMaterial({ color: 0x0000aa }));
            p.position.y = -0.3; player.add(p);
            player.position.set(0, 5, 0); scene.add(player);
        }

        function createPowerup(x, y, z, type) {
            const g = new THREE.Mesh(new THREE.SphereGeometry(0.5), new THREE.MeshStandardMaterial({color: type==='mushroom'?0xff0000:0xffaa00}));
            g.position.set(x,y,z); g.userData = { type }; scene.add(g); powerups.push({ mesh: g, type });
        }

        function shootFireball() {
            const f = new THREE.Mesh(new THREE.SphereGeometry(0.25), new THREE.MeshStandardMaterial({color: 0xff4400, emissive: 0xff0000}));
            const dx = Math.sin(player.rotation.y), dz = Math.cos(player.rotation.y);
            f.position.set(player.position.x + dx, player.position.y, player.position.z + dz);
            f.userData = { vx: dx*0.4, vz: dz*0.4, life: 60 };
            scene.add(f); projectiles.push(f);
        }

        function createClouds() {
            for(let i=0; i<20; i++) {
                const c = new THREE.Mesh(new THREE.BoxGeometry(5,1,3), new THREE.MeshStandardMaterial({color: 0xffffff, transparent: true, opacity: 0.6}));
                c.position.set((Math.random()-0.5)*200, 20+Math.random()*10, (Math.random()-0.5)*200);
                scene.add(c); clouds.push({mesh: c, speed: 0.02});
            }
        }

        function restartGame(full) {
            if (full) { currentCheckpoint = { x: 0, y: 5, z: 0, rot: Math.PI }; generateLevel(); }
            player.position.set(currentCheckpoint.x, currentCheckpoint.y, currentCheckpoint.z);
            velocityX = 0; velocityY = 0; velocityZ = 0; jumpCount = 0;
            isBig = false; hasFirePower = false; isImmune = true; 
            player.scale.set(1,1,1); player.children[0].material.color.setHex(0xff0000);
            setTimeout(() => isImmune = false, 2000);
            document.getElementById('game-over').style.display = 'none';
            isGameOver = false; isPaused = false;
        }

        async function report(action, payload = {}) { await fetch('/api/mario', { method: 'POST', body: JSON.stringify({ action, id: mp.id, payload }) }); }

        function handlePlayerDeath() { if(isImmune || isGameOver) return; report('death'); restartGame(false); }

        function onMouseMove(e) {
            if (isPaused || isGameOver || document.pointerLockElement !== renderer.domElement) return;
            targetRotationY -= e.movementX * gameConfig.sensitivity;
            targetRotationX = Math.max(0.1, Math.min(1.4, targetRotationX + e.movementY * gameConfig.sensitivity));
        }

        function onWindowResize() { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }

        function endGame(win) {
            isGameOver = true; document.exitPointerLock();
            document.getElementById('game-over').style.display = 'block';
            document.getElementById('status-text').innerText = win ? "GEWONNEN!" : "GAME OVER";
            if(win) report('finish');
        }

        function animate() {
            requestAnimationFrame(animate);
            if (isPaused || isGameOver) return;

            mp.sync();

            let ix = 0, iz = 0;
            if(keys['KeyW']) iz += 1; if(keys['KeyS']) iz -= 1; if(keys['KeyA']) ix += 1; if(keys['KeyD']) ix -= 1;
            if(ix !== 0 || iz !== 0) {
                const len = Math.sqrt(ix*ix + iz*iz);
                const dx = (Math.cos(targetRotationY)*ix + Math.sin(targetRotationY)*iz)/len;
                const dz = (-Math.sin(targetRotationY)*ix + Math.cos(targetRotationY)*iz)/len;
                velocityX += dx * acceleration; velocityZ += dz * acceleration;
                player.rotation.y = targetRotationY + Math.atan2(ix, iz);
            }
            velocityX *= friction; velocityZ *= friction;
            player.position.x += velocityX; player.position.z += velocityZ;
            velocityY += gravity; player.position.y += velocityY;

            // Physics & Collisions
            platforms.forEach(p => {
                const hw = p.w/2+0.4, hd = p.d/2+0.4;
                if(Math.abs(player.position.x - p.mesh.position.x) < hw && Math.abs(player.position.z - p.mesh.position.z) < hd) {
                    const top = p.mesh.position.y + p.h/2;
                    if(velocityY <= 0 && player.position.y - 0.5 >= top - 0.5 && player.position.y - 0.5 + velocityY <= top + 0.1) {
                        player.position.y = top + 0.5; velocityY = 0; jumpCount = 0;
                    }
                }
            });

            stars.forEach((s,i) => {
                s.rotation.y += 0.05;
                if(player.position.distanceTo(s.position) < 1.2) { scene.remove(s); stars.splice(i,1); report('score', {amount: 100, isStar: true}); }
            });

            checkpoints.forEach(cp => {
                if(!cp.active && player.position.distanceTo(cp.mesh.position) < 2) {
                    cp.active = true; currentCheckpoint = { ...cp.pos, rot: player.rotation.y };
                    document.getElementById('checkpoint-msg').style.display = 'block';
                    setTimeout(() => document.getElementById('checkpoint-msg').style.display = 'none', 2000);
                }
            });

            if(flag && player.position.distanceTo(flag.position) < 2) endGame(true);

            // Camera
            const d = 8;
            camera.position.lerp(new THREE.Vector3(
                player.position.x - Math.sin(targetRotationY)*Math.cos(targetRotationX)*d,
                player.position.y + Math.sin(targetRotationX)*d + 1.5,
                player.position.z - Math.cos(targetRotationY)*Math.cos(targetRotationX)*d
            ), 0.1);
            camera.lookAt(player.position.x, player.position.y+1, player.position.z);

            if(player.position.y < -30) handlePlayerDeath();
            renderer.render(scene, camera);
        }

        window.onload = init;
    </script>
</body>
</html>