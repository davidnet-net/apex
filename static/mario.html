<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Mario - Multiplayer Edition</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #5c94fc;
            font-family: 'Segoe UI', sans-serif;
            user-select: none;
        }

        /* Nieuwe Compacte UI Rechtsboven */
        #stats-container {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: flex-end;
            pointer-events: none;
            z-index: 10;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
            padding: 8px 15px;
            border-radius: 20px;
            color: white;
            font-weight: bold;
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 10px;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
        }

        .heart-icon { color: #ff4444; font-size: 20px; }
        .star-icon { color: #ffd700; font-size: 20px; }
        .score-icon { color: #4caf50; font-size: 20px; }
        .fps-icon   { color: #00ffff; font-size: 20px; }

        /* Settings knop */
        #settings-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: auto;
            cursor: pointer;
            font-size: 24px;
            background: rgba(0,0,0,0.6);
            color: white;
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 50%;
            width: 45px;
            height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s, background 0.2s;
            z-index: 11;
        }
        #settings-btn:hover { transform: scale(1.1); background: rgba(0,0,0,0.8); }

        /* Settings Menu */
        #settings-menu {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 40, 0.95);
            color: white;
            padding: 30px;
            border-radius: 15px;
            border: 2px solid #5c94fc;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
            z-index: 100;
            width: 300px;
            text-align: center;
        }

        .setting-row { margin-bottom: 20px; text-align: left; }
        label { display: block; margin-bottom: 5px; font-weight: bold; color: #88ccff; }
        input[type=range] { width: 100%; cursor: pointer; }
        .val-display { float: right; color: #f8b800; }

        /* Instructies & Game Over */
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            backdrop-filter: blur(5px);
            color: white;
            padding: 10px 25px;
            border-radius: 30px;
            font-size: 14px;
            text-align: center;
            border: 1px solid rgba(255,255,255,0.3);
            pointer-events: none;
        }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            display: none;
            border: 4px solid gold;
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.5);
            z-index: 20;
        }

        button.menu-btn {
            background: linear-gradient(to bottom, #f8b800, #d49000);
            border: none;
            padding: 12px 30px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 8px;
            margin-top: 20px;
            color: #333;
            box-shadow: 0 4px 0 #b07000;
            transition: transform 0.1s;
        }
        button.menu-btn:active { transform: translateY(4px); box-shadow: 0 0 0 #b07000; }

        #powerup-msg, #checkpoint-msg {
            display: none;
            position: absolute;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: bold;
            text-shadow: 2px 2px 4px #000;
            pointer-events: none;
        }

        #powerup-msg { color: #ffff00; font-size: 30px; top: 20%; animation: popUp 1s forwards; }
        #checkpoint-msg { color: #00ff00; font-size: 24px; top: 30%; animation: fadeUp 2s forwards; }

        @keyframes popUp {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            100% { transform: translate(-50%, -150%) scale(1); opacity: 0; }
        }
        @keyframes fadeUp {
            0% { transform: translate(-50%, 0); opacity: 0; }
            20% { transform: translate(-50%, -20px); opacity: 1; }
            80% { transform: translate(-50%, -20px); opacity: 1; }
            100% { transform: translate(-50%, -50px); opacity: 0; }
        }
    </style>
</head>
<body>

    <button id="settings-btn" onclick="openSettings()">‚öôÔ∏è</button>

    <div id="stats-container">
        <div class="stat-box">
            <span class="fps-icon">‚ö°</span> <span id="fps-counter">60</span> FPS
        </div>
        <div class="stat-box">
            <span class="heart-icon">‚ù§Ô∏è</span> <span id="lives">3</span>
        </div>
        <div class="stat-box">
            <span class="star-icon">‚≠ê</span> <span id="stars">0</span> / <span id="total-stars">0</span>
        </div>
        <div class="stat-box">
            <span class="score-icon">üèÜ</span> <span id="score">0</span>
        </div>
    </div>
    
    <div id="powerup-msg">POWER UP!</div>
    <div id="checkpoint-msg">CHECKPOINT BEREIKT!</div>

    <div id="settings-menu">
        <h2 style="color: gold; text-shadow: 2px 2px 0 #000;">Instellingen</h2>
        <div class="setting-row">
            <label>Level Lengte (Segmenten) <span id="val-len" class="val-display">8</span></label>
            <input type="range" id="opt-length" min="4" max="20" step="1" value="8" oninput="updateSettingsUI()">
        </div>
        <div class="setting-row">
            <label>Gevoeligheid <span id="val-sens" class="val-display">4</span></label>
            <input type="range" id="opt-sens" min="1" max="20" step="1" value="4" oninput="updateSettingsUI()">
        </div>
        <div class="setting-row">
            <label>Max FPS <span id="val-fps" class="val-display">60</span></label>
            <input type="range" id="opt-fps" min="30" max="144" step="30" value="60" oninput="updateSettingsUI()">
        </div>
        <button class="menu-btn" onclick="closeSettings()">Opslaan & Sluiten</button>
    </div>

    <div id="instructions">
        <b>WASD</b> lopen | <b>Spatie (x2)</b> springen | <b>F</b> vuurbal | <b>Muis</b> kijken
    </div>

    <div id="game-over">
        <h1 id="status-text">GEWONNEN!</h1>
        <p id="end-msg">Je hebt de vlag bereikt!</p>
        <button class="menu-btn" onclick="restartGame(true)">Opnieuw Spelen</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        /**
         * MultiplayerManager zorgt voor synchronisatie tussen alle spelers.
         */
        class MultiplayerManager {
            /**
             * @param {THREE.Scene} scene De hoofdscene om andere spelers aan toe te voegen.
             */
            constructor(scene) {
                this.scene = scene;
                this.id = 'player_' + Math.random().toString(36).substr(2, 9);
                this.remotePlayers = new Map(); // ID -> Mesh
                this.lastSeed = null;
                this.syncInterval = 100; // ms
                this.lastSync = 0;
            }

            /**
             * Haalt updates van de server en verwerkt de gedeelde staat.
             */
            async sync() {
                const now = performance.now();
                if (now - this.lastSync < this.syncInterval) return;
                this.lastSync = now;

                try {
                    const response = await fetch('/api/mario', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            action: 'update',
                            id: this.id,
                            payload: {
                                x: player.position.x,
                                y: player.position.y,
                                z: player.position.z,
                                rot: player.rotation.y,
                                isBig: isBig,
                                hasFirePower: hasFirePower
                            }
                        })
                    });

                    const data = await response.json();
                    this.handleGlobalState(data.gameState);
                    this.updateRemotePlayers(data.players);
                } catch (e) {
                    console.error("Multiplayer Sync Fout:", e);
                }
            }

            /**
             * Verwerkt gedeelde levens en level overgangen.
             */
            handleGlobalState(state) {
                // Update gedeelde levens
                lives = state.sharedLives;
                document.getElementById('lives').innerText = lives;
                if (lives <= 0 && !isGameOver) endGame(false);

                // Update gedeelde score/sterren
                starsCollected = state.totalStarsCollected;
                document.getElementById('stars').innerText = starsCollected;

                // Als level-zaadje veranderd is (iemand heeft de finish bereikt)
                if (this.lastSeed !== null && this.lastSeed !== state.levelSeed) {
                    this.lastSeed = state.levelSeed;
                    Math.seedrandom = state.levelSeed; // Optionele pseudo-random
                    restartGame(true);
                }
                this.lastSeed = state.levelSeed;
            }

            /**
             * Update de visuele representatie van andere spelers.
             */
            updateRemotePlayers(players) {
                const activeIds = new Set(players.map(p => p.id));

                // Verwijder weggegane spelers
                for (let [id, mesh] of this.remotePlayers.entries()) {
                    if (!activeIds.has(id)) {
                        this.scene.remove(mesh);
                        this.remotePlayers.delete(id);
                    }
                }

                // Update posities
                players.forEach(p => {
                    let mesh = this.remotePlayers.get(p.id);
                    if (!mesh) {
                        mesh = this.createGhostMesh();
                        this.scene.add(mesh);
                        this.remotePlayers.set(p.id, mesh);
                    }
                    mesh.position.lerp(new THREE.Vector3(p.x, p.y, p.z), 0.3);
                    mesh.rotation.y = p.rot;
                    const scale = p.isBig ? 1.5 : 1;
                    mesh.scale.set(scale, scale, scale);
                });
            }

            /**
             * Maakt een blauwe kubus representatie van een andere speler.
             */
            createGhostMesh() {
                const group = new THREE.Group();
                const mat = new THREE.MeshStandardMaterial({ color: 0x00aaff, transparent: true, opacity: 0.8 });
                const body = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), mat);
                group.add(body);
                return group;
            }

            /**
             * Meldt een dood aan de server zodat levens voor iedereen afnemen.
             */
            async reportDeath() {
                await fetch('/api/mario', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action: 'death', id: this.id })
                });
            }

            /**
             * Meldt de finish voor iedereen.
             */
            async reportFinish() {
                await fetch('/api/mario', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action: 'finish', id: this.id })
                });
            }
        }

        // --- CONFIGURATIE & SETTINGS ---
        let gameConfig = {
            levelLength: 8,
            sensitivity: 0.002, 
            maxFPS: 60
        };

        let fpsInterval, now, then, elapsed;
        let frameCount = 0;
        let lastTimeFPS = 0;

        let scene, camera, renderer, player, clock, mpManager;
        let platforms = [], movingPlatforms = [], stars = [], goombas = [], thwomps = [], bulletBills = [], bullets = [], particles = [], powerups = [], projectiles = [], clouds = [], checkpoints = []; 
        let flag = null, score = 0, starsCollected = 0, totalStarsInLevel = 0, isGameOver = false, isPaused = false;
        let lives = 3, currentCheckpoint = { x: 0, y: 5, z: 0, rot: Math.PI }, isBig = false, hasFirePower = false, isImmune = false; 

        const keys = {};
        let targetRotationY = Math.PI, targetRotationX = 0.4;
        const gravity = -0.015, acceleration = 0.025, friction = 0.85, maxSpeed = 0.35; 
        let velocityX = 0, velocityZ = 0, velocityY = 0, jumpCount = 0, maxJumps = 2, currentPlatform = null;
        const textures = {};

        function generateTextures() {
            function getCtx(w, h) {
                const c = document.createElement('canvas');
                c.width = w; c.height = h;
                return {c, ctx: c.getContext('2d')};
            }
            let t = getCtx(256, 256);
            t.ctx.fillStyle = '#2e7d32'; t.ctx.fillRect(0,0,256,256);
            for(let i=0; i<3000; i++) {
                t.ctx.fillStyle = Math.random() > 0.5 ? '#4caf50' : '#1b5e20';
                t.ctx.fillRect(Math.random()*256, Math.random()*256, 2+Math.random()*4, 2+Math.random()*4);
            }
            textures['grass'] = new THREE.CanvasTexture(t.c);
            textures['grass'].wrapS = textures['grass'].wrapT = THREE.RepeatWrapping;

            t = getCtx(256, 256);
            t.ctx.fillStyle = '#8d6e63'; t.ctx.fillRect(0,0,256,256); t.ctx.fillStyle = '#bf360c';
            for(let y=0; y<4; y++) for(let x=0; x<4; x++) {
                let offX = (y % 2 === 0) ? 0 : 32;
                t.ctx.fillRect((x*64 + offX) % 256 + 2, y*64 + 2, 60, 60);
            }
            textures['brick'] = new THREE.CanvasTexture(t.c);
            textures['brick'].wrapS = textures['brick'].wrapT = THREE.RepeatWrapping;

            t = getCtx(256, 256);
            t.ctx.fillStyle = '#757575'; t.ctx.fillRect(0,0,256,256);
            textures['stone'] = new THREE.CanvasTexture(t.c);
            textures['stone'].wrapS = textures['stone'].wrapT = THREE.RepeatWrapping;

            t = getCtx(256, 256);
            t.ctx.fillStyle = '#6d4c41'; t.ctx.fillRect(0,0,256,256);
            textures['wood'] = new THREE.CanvasTexture(t.c);
            textures['wood'].wrapS = textures['wood'].wrapT = THREE.RepeatWrapping;

            t = getCtx(128, 128);
            t.ctx.fillStyle = '#ffd700'; t.ctx.fillRect(0,0,128,128);
            textures['gold'] = new THREE.CanvasTexture(t.c);
        }

        function updateSettingsUI() {
            document.getElementById('val-len').innerText = document.getElementById('opt-length').value;
            document.getElementById('val-sens').innerText = document.getElementById('opt-sens').value;
            let fpsVal = document.getElementById('opt-fps').value;
            document.getElementById('val-fps').innerText = fpsVal > 120 ? "Max" : fpsVal;
        }

        function openSettings() {
            isPaused = true;
            document.exitPointerLock();
            document.getElementById('settings-menu').style.display = 'block';
        }

        function closeSettings() {
            let oldLen = gameConfig.levelLength;
            gameConfig.levelLength = parseInt(document.getElementById('opt-length').value);
            gameConfig.sensitivity = parseInt(document.getElementById('opt-sens').value) * 0.0005;
            gameConfig.maxFPS = parseInt(document.getElementById('opt-fps').value);
            fpsInterval = 1000 / gameConfig.maxFPS;
            document.getElementById('settings-menu').style.display = 'none';
            isPaused = false;
            renderer.domElement.requestPointerLock();
            if (oldLen !== gameConfig.levelLength) restartGame(true); else animate();
        }

        function init() {
            generateTextures(); 
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x6fa8ff);
            scene.fog = new THREE.Fog(0x6fa8ff, 20, 150);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);
            clock = new THREE.Clock();

            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.7); scene.add(hemiLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.2); dirLight.position.set(50, 80, 50); dirLight.castShadow = true; scene.add(dirLight);

            mpManager = new MultiplayerManager(scene);

            createPlayer();
            createClouds(); 
            generateLevel();

            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', e => keys[e.code] = false);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('resize', onWindowResize);

            renderer.domElement.addEventListener('click', () => { if (!isPaused && !isGameOver) renderer.domElement.requestPointerLock(); });

            fpsInterval = 1000 / gameConfig.maxFPS;
            then = Date.now(); lastTimeFPS = performance.now();
            animate();
        }

        function restartGame(fullReset) {
            if (fullReset) {
                score = 0; starsCollected = 0;
                currentCheckpoint = { x: 0, y: 5, z: 0, rot: Math.PI };
                generateLevel();
            }
            player.position.set(currentCheckpoint.x, currentCheckpoint.y, currentCheckpoint.z);
            targetRotationY = currentCheckpoint.rot; 
            player.rotation.set(0, targetRotationY, 0);
            velocityX = 0; velocityZ = 0; velocityY = 0; jumpCount = 0; currentPlatform = null;
            isBig = false; hasFirePower = false; isImmune = true; 
            setTimeout(() => { isImmune = false; }, 2000); 
            updatePlayerAppearance();
            player.scale.set(1, 1, 1);
            document.getElementById('game-over').style.display = 'none';
            isGameOver = false; isPaused = false;
        }

        function handlePlayerDeath() {
            if (isImmune || isGameOver) return;
            mpManager.reportDeath();
            restartGame(false);
        }

        function onKeyDown(e) {
            if (isGameOver || isPaused) return;
            keys[e.code] = true;
            if (e.code === 'Space') {
                if (jumpCount < maxJumps) {
                    velocityY = 0.42; jumpCount++; currentPlatform = null;
                    if (jumpCount === 2) { createJumpEffect(player.position.x, player.position.y - 0.5, player.position.z); velocityY = 0.45; }
                }
            }
            if (e.code === 'KeyF' && hasFirePower) shootFireball();
        }

        function clearWorld() {
            platforms.forEach(p => scene.remove(p.mesh)); platforms = []; movingPlatforms = [];
            stars.forEach(s => scene.remove(s)); stars = []; totalStarsInLevel = 0;
            goombas.forEach(g => scene.remove(g.mesh)); goombas = [];
            thwomps.forEach(t => scene.remove(t.mesh)); thwomps = [];
            bulletBills.forEach(b => scene.remove(b.mesh)); bulletBills = [];
            bullets.forEach(b => scene.remove(b.mesh)); bullets = [];
            powerups.forEach(p => scene.remove(p.mesh)); powerups = [];
            projectiles.forEach(p => scene.remove(p.mesh)); projectiles = [];
            particles.forEach(p => scene.remove(p)); particles = [];
            checkpoints.forEach(cp => scene.remove(cp.mesh)); checkpoints = []; 
            if (flag) { scene.remove(flag); flag = null; }
        }

        function createClouds() {
            clouds.forEach(c => scene.remove(c)); clouds = [];
            const geo = new THREE.BoxGeometry(1,1,1);
            const mat = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, transparent: true, opacity: 0.8 });
            for(let i=0; i<30; i++) {
                const cloud = new THREE.Group();
                for(let j=0; j<4; j++) {
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.position.set(j*0.8, 0, 0); mesh.scale.set(2, 1, 1.5); cloud.add(mesh);
                }
                cloud.position.set((Math.random()-0.5)*200, 30, (Math.random()-0.5)*200);
                scene.add(cloud); clouds.push({mesh: cloud, speed: 0.02 + Math.random() * 0.03});
            }
        }

        function generateLevel() {
            clearWorld();
            createPlatform(0, 0, 0, 8, 1, 8, 'grass', 'box');
            let currentX = 0, currentY = 0, currentZ = 0, currentAngle = -Math.PI; 
            const availableBuildings = [
                { type: 'tower' }, { type: 'spiral' }, { type: 'ruins' }, { type: 'castle' }
            ];
            for (let s = 0; s < gameConfig.levelLength; s++) {
                const seg = availableBuildings[Math.floor(Math.random() * availableBuildings.length)];
                for(let i=0; i<4; i++) {
                    currentAngle += (Math.random() - 0.5) * 0.8;
                    let dist = 5 + Math.random() * 2;
                    currentX += Math.sin(currentAngle) * dist; currentZ += Math.cos(currentAngle) * dist;
                    currentY += (Math.random() * 2.0) - 0.5;
                    createPlatform(currentX, currentY, currentZ, 4, 1, 4, 'grass', 'box');
                }
                let bX = currentX + Math.sin(currentAngle) * 8, bZ = currentZ + Math.cos(currentAngle) * 8;
                let exit;
                if(seg.type === 'tower') exit = createBuildingTower(bX, currentY, bZ);
                else exit = createSpiralStaircase(bX, currentY, bZ);
                createCheckpoint(exit.x, exit.y, exit.z);
                currentX = exit.x; currentY = exit.y; currentZ = exit.z;
            }
            createPlatform(currentX + 10, currentY, currentZ, 6, 1, 6, 'gold', 'box');
            createFlag(currentX + 10, currentY + 0.5, currentZ);
            document.getElementById('total-stars').innerText = totalStarsInLevel;
        }

        function createPlatform(x, y, z, w, h, d, typeOrColor, shapeType) {
            const geo = shapeType === 'cylinder' ? new THREE.CylinderGeometry(w/2, w/2, h, 32) : new THREE.BoxGeometry(w, h, d);
            const mat = new THREE.MeshStandardMaterial({ 
                map: textures[typeOrColor] || null, 
                color: textures[typeOrColor] ? 0xffffff : typeOrColor 
            });
            const mesh = new THREE.Mesh(geo, mat); mesh.position.set(x, y, z); mesh.receiveShadow = true; mesh.castShadow = true;
            scene.add(mesh); platforms.push({ mesh, w, h, d, type: shapeType });
        }

        function createBuildingTower(x, y, z) {
            createPlatform(x, y, z, 10, 1, 10, 'stone', 'box');
            createPlatform(x, y + 5, z, 4, 10, 4, 'brick', 'box');
            return { x, y: y + 10, z };
        }

        function createSpiralStaircase(x, y, z) {
            createPlatform(x, y, z, 8, 1, 8, 'stone', 'box');
            return { x, y, z };
        }

        function createCheckpoint(x, y, z) {
            const group = new THREE.Group();
            createPlatform(x, y - 0.5, z, 2.5, 1, 2.5, 'stone', 'box');
            const flagMesh = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.6, 0.05), new THREE.MeshStandardMaterial({ color: 0x00FF00 }));
            flagMesh.position.set(0.4, 1.6, 0); group.add(flagMesh);
            group.position.set(x, y, z); scene.add(group);
            checkpoints.push({ mesh: group, flagMesh, active: false, pos: { x, y: y+1, z } });
        }

        function createFlag(x, y, z) {
            flag = new THREE.Group();
            const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 4), new THREE.MeshStandardMaterial({ color: 0x888888 }));
            pole.position.y = 2; flag.add(pole);
            const sail = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1, 0.1), new THREE.MeshStandardMaterial({ color: 0x00ff00 }));
            sail.position.set(0.75, 3.5, 0); flag.add(sail);
            flag.position.set(x, y, z); scene.add(flag);
        }

        function createPlayer() {
            player = new THREE.Group();
            const body = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), new THREE.MeshStandardMaterial({ color: 0xff0000 }));
            body.castShadow = true; player.add(body);
            const pants = new THREE.Mesh(new THREE.BoxGeometry(1.02, 0.4, 1.02), new THREE.MeshStandardMaterial({ color: 0x0000aa }));
            pants.position.y = -0.3; player.add(pants);
            player.position.set(0, 5, 0); scene.add(player);
        }

        function updatePlayerAppearance() {
            player.children[0].material.color.setHex(hasFirePower ? 0xFFFFFF : 0xFF0000);
        }

        function onMouseMove(e) {
            if (isPaused || isGameOver) return;
            if (document.pointerLockElement === renderer.domElement) {
                targetRotationY -= e.movementX * gameConfig.sensitivity;
                targetRotationX += e.movementY * gameConfig.sensitivity;
                targetRotationX = Math.max(0.1, Math.min(Math.PI/2.2, targetRotationX));
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateCamera() {
            const distance = 8;
            const camX = player.position.x - Math.sin(targetRotationY) * Math.cos(targetRotationX) * distance;
            const camY = player.position.y + Math.sin(targetRotationX) * distance + 1.5;
            const camZ = player.position.z - Math.cos(targetRotationY) * Math.cos(targetRotationX) * distance;
            camera.position.lerp(new THREE.Vector3(camX, camY, camZ), 0.1);
            camera.lookAt(player.position.x, player.position.y + 1, player.position.z);
        }

        function checkVerticalCollisions() {
            const playerBottom = player.position.y - (0.5 * player.scale.y);
            platforms.forEach(p => {
                const halfW = p.w / 2 + 0.4, halfD = p.d / 2 + 0.4;
                if (Math.abs(player.position.x - p.mesh.position.x) < halfW && Math.abs(player.position.z - p.mesh.position.z) < halfD) {
                    const platformTop = p.mesh.position.y + p.h/2;
                    if (velocityY <= 0 && playerBottom >= platformTop - 0.5 && playerBottom + velocityY <= platformTop + 0.1) {
                        player.position.y = platformTop + (0.5 * player.scale.y); velocityY = 0; jumpCount = 0; currentPlatform = p;
                    }
                }
            });
        }

        function endGame(win) {
            isGameOver = true; document.exitPointerLock(); 
            document.getElementById('game-over').style.display = 'block';
            const statusText = document.getElementById('status-text');
            if (win) { statusText.innerText = "GEWONNEN!"; statusText.style.color = "gold"; }
            else { statusText.innerText = "GAME OVER"; statusText.style.color = "#ff4444"; }
        }

        function animate() {
            requestAnimationFrame(animate);
            if (isPaused || isGameOver) return;

            now = Date.now(); elapsed = now - then;
            if (now - lastTimeFPS >= 1000) { document.getElementById('fps-counter').innerText = frameCount; frameCount = 0; lastTimeFPS = now; }

            if (elapsed > fpsInterval) {
                then = now - (elapsed % fpsInterval);
                frameCount++;

                mpManager.sync();

                let inputX = 0, inputZ = 0;
                if (keys['KeyW']) inputZ += 1; if (keys['KeyS']) inputZ -= 1;
                if (keys['KeyA']) inputX += 1; if (keys['KeyD']) inputX -= 1;

                if (inputX !== 0 || inputZ !== 0) {
                    const length = Math.sqrt(inputX * inputX + inputZ * inputZ);
                    const targetDirX = (Math.cos(targetRotationY) * (inputX/length) + Math.sin(targetRotationY) * (inputZ/length));
                    const targetDirZ = (-Math.sin(targetRotationY) * (inputX/length) + Math.cos(targetRotationY) * (inputZ/length));
                    velocityX += targetDirX * acceleration; velocityZ += targetDirZ * acceleration;
                    player.rotation.y = targetRotationY + Math.atan2(inputX, inputZ);
                }

                velocityX *= friction; velocityZ *= friction;
                player.position.x += velocityX; player.position.z += velocityZ;
                velocityY += gravity; player.position.y += velocityY;

                checkVerticalCollisions();
                updateCamera();

                if (flag && player.position.distanceTo(flag.position) < 2.5) {
                    mpManager.reportFinish();
                    endGame(true);
                }

                if (player.position.y < -30) handlePlayerDeath(); 
                renderer.render(scene, camera);
            }
        }

        window.onload = init;
    </script>
</body>
</html>