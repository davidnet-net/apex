<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Mario - Full Features Restored</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #5c94fc;
            font-family: 'Segoe UI', sans-serif;
            user-select: none;
        }

        /* UI Rechtsboven */
        #stats-container {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: flex-end;
            pointer-events: none;
            z-index: 10;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
            padding: 8px 15px;
            border-radius: 20px;
            color: white;
            font-weight: bold;
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 10px;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
        }

        .heart-icon { color: #ff4444; font-size: 20px; }
        .star-icon { color: #ffd700; font-size: 20px; }
        .score-icon { color: #4caf50; font-size: 20px; }
        .fps-icon   { color: #00ffff; font-size: 20px; }

        /* Settings knop */
        #settings-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: auto;
            cursor: pointer;
            font-size: 24px;
            background: rgba(0,0,0,0.6);
            color: white;
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 50%;
            width: 45px;
            height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s, background 0.2s;
            z-index: 11;
        }
        #settings-btn:hover { transform: scale(1.1); background: rgba(0,0,0,0.8); }

        /* Settings Menu */
        #settings-menu {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 40, 0.95);
            color: white;
            padding: 30px;
            border-radius: 15px;
            border: 2px solid #5c94fc;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
            z-index: 100;
            width: 300px;
            text-align: center;
        }

        .setting-row { margin-bottom: 20px; text-align: left; }
        label { display: block; margin-bottom: 5px; font-weight: bold; color: #88ccff; }
        input[type=range] { width: 100%; cursor: pointer; }
        .val-display { float: right; color: #f8b800; }

        /* Instructies & Game Over */
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            backdrop-filter: blur(5px);
            color: white;
            padding: 10px 25px;
            border-radius: 30px;
            font-size: 14px;
            text-align: center;
            border: 1px solid rgba(255,255,255,0.3);
            pointer-events: none;
        }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            display: none;
            border: 4px solid gold;
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.5);
            z-index: 20;
        }

        button.menu-btn {
            background: linear-gradient(to bottom, #f8b800, #d49000);
            border: none;
            padding: 12px 30px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 8px;
            margin-top: 20px;
            color: #333;
            box-shadow: 0 4px 0 #b07000;
            transition: transform 0.1s;
        }
        button.menu-btn:active { transform: translateY(4px); box-shadow: 0 0 0 #b07000; }

        /* Powerup Pop-up */
        #powerup-msg {
            display: none;
            color: #ffff00;
            font-size: 30px;
            font-weight: bold;
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-shadow: 0 0 10px #ff0000, 2px 2px 0px #000;
            animation: popUp 1s forwards;
            pointer-events: none;
        }

        /* Checkpoint bericht */
        #checkpoint-msg {
            display: none;
            color: #00ff00;
            font-size: 24px;
            font-weight: bold;
            position: absolute;
            top: 30%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-shadow: 2px 2px 4px #000;
            animation: fadeUp 2s forwards;
            pointer-events: none;
        }

        @keyframes popUp {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            100% { transform: translate(-50%, -150%) scale(1); opacity: 0; }
        }
        @keyframes fadeUp {
            0% { transform: translate(-50%, 0); opacity: 0; }
            20% { transform: translate(-50%, -20px); opacity: 1; }
            80% { transform: translate(-50%, -20px); opacity: 1; }
            100% { transform: translate(-50%, -50px); opacity: 0; }
        }
    </style>
</head>
<body>

    <button id="settings-btn" onclick="openSettings()">‚öôÔ∏è</button>

    <div id="stats-container">
        <div class="stat-box">
            <span class="fps-icon">‚ö°</span> <span id="fps-counter">60</span> FPS
        </div>
        <div class="stat-box">
            <span class="heart-icon">‚ù§Ô∏è</span> <span id="lives">3</span>
        </div>
        <div class="stat-box">
            <span class="star-icon">‚≠ê</span> <span id="stars">0</span> / <span id="total-stars">0</span>
        </div>
        <div class="stat-box">
            <span class="score-icon">üèÜ</span> <span id="score">0</span>
        </div>
    </div>
    
    <div id="powerup-msg">POWER UP!</div>
    <div id="checkpoint-msg">CHECKPOINT BEREIKT!</div>

    <div id="settings-menu">
        <h2 style="color: gold; text-shadow: 2px 2px 0 #000;">Instellingen</h2>
        <div class="setting-row">
            <label>Level Lengte (Segmenten) <span id="val-len" class="val-display">8</span></label>
            <input type="range" id="opt-length" min="4" max="20" step="1" value="8" oninput="updateSettingsUI()">
        </div>
        <div class="setting-row">
            <label>Gevoeligheid <span id="val-sens" class="val-display">4</span></label>
            <input type="range" id="opt-sens" min="1" max="20" step="1" value="4" oninput="updateSettingsUI()">
        </div>
        <div class="setting-row">
            <label>Max FPS <span id="val-fps" class="val-display">60</span></label>
            <input type="range" id="opt-fps" min="30" max="144" step="30" value="60" oninput="updateSettingsUI()">
        </div>
        <button class="menu-btn" onclick="closeSettings()">Opslaan & Sluiten</button>
    </div>

    <div id="instructions">
        <b>WASD</b> lopen | <b>Spatie (x2)</b> springen | <b>F</b> vuurbal | <b>Muis</b> kijken
    </div>

    <div id="game-over">
        <h1 id="status-text">GEWONNEN!</h1>
        <p id="end-msg">Je hebt de vlag bereikt!</p>
        <button class="menu-btn" onclick="restartGame(true)">Opnieuw Spelen</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- CONFIGURATIE ---
        let gameConfig = {
            levelLength: 8,
            sensitivity: 0.002, 
            maxFPS: 60
        };

        let fpsInterval, now, then, elapsed;
        let frameCount = 0;
        let lastTimeFPS = 0;

        let scene, camera, renderer, player, clock;
        let platforms = [];
        let movingPlatforms = [];
        let stars = [];
        let goombas = [];
        let thwomps = []; 
        let bulletBills = [];
        let bullets = []; 
        let particles = [];
        let powerups = []; 
        let projectiles = [];
        let clouds = [];
        let checkpoints = []; 
        let flag = null;
        let score = 0;
        let starsCollected = 0;
        let totalStarsInLevel = 0;
        let isGameOver = false;
        let isPaused = false;

        let lives = 3;
        let currentCheckpoint = { x: 0, y: 5, z: 0, rot: Math.PI }; 
        let isBig = false;
        let hasFirePower = false;
        let isImmune = false; 

        const keys = {};
        let targetRotationY = Math.PI;
        let targetRotationX = 0.4;

        const gravity = -0.015;
        let velocityX = 0, velocityZ = 0, velocityY = 0;
        const acceleration = 0.025, friction = 0.85, maxSpeed = 0.35;      

        let jumpCount = 0;
        const maxJumps = 2; 
        let currentPlatform = null;

        const textures = {};

        function generateTextures() {
            function getCtx(w, h) {
                const c = document.createElement('canvas');
                c.width = w; c.height = h;
                return {c, ctx: c.getContext('2d')};
            }
            // Gras
            let t = getCtx(256, 256);
            t.ctx.fillStyle = '#2e7d32'; t.ctx.fillRect(0,0,256,256);
            for(let i=0; i<2000; i++) {
                t.ctx.fillStyle = Math.random() > 0.5 ? '#4caf50' : '#1b5e20';
                t.ctx.fillRect(Math.random()*256, Math.random()*256, 2, 2);
            }
            textures['grass'] = new THREE.CanvasTexture(t.c);
            textures['grass'].wrapS = textures['grass'].wrapT = THREE.RepeatWrapping;

            // Baksteen
            t = getCtx(256, 256);
            t.ctx.fillStyle = '#8d6e63'; t.ctx.fillRect(0,0,256,256); t.ctx.fillStyle = '#bf360c';
            for(let y=0; y<4; y++) for(let x=0; x<4; x++) {
                t.ctx.fillRect(x*64+2, y*64+2, 60, 60);
            }
            textures['brick'] = new THREE.CanvasTexture(t.c);
            textures['brick'].wrapS = textures['brick'].wrapT = THREE.RepeatWrapping;

            // Steen
            t = getCtx(256, 256);
            t.ctx.fillStyle = '#757575'; t.ctx.fillRect(0,0,256,256);
            for(let i=0; i<300; i++) {
                t.ctx.fillStyle = Math.random() > 0.5 ? '#9e9e9e' : '#616161';
                t.ctx.beginPath(); t.ctx.arc(Math.random()*256, Math.random()*256, Math.random()*8+2, 0, Math.PI*2); t.ctx.fill();
            }
            textures['stone'] = new THREE.CanvasTexture(t.c);
            textures['stone'].wrapS = textures['stone'].wrapT = THREE.RepeatWrapping;

             // Hout
            t = getCtx(256, 256);
            t.ctx.fillStyle = '#6d4c41'; t.ctx.fillRect(0,0,256,256); t.ctx.fillStyle = '#4e342e';
            for(let i=0; i<20; i++) t.ctx.fillRect(0, i*12.8, 256, 2);
            textures['wood'] = new THREE.CanvasTexture(t.c);
            textures['wood'].wrapS = textures['wood'].wrapT = THREE.RepeatWrapping;

            t = getCtx(128, 128);
            t.ctx.fillStyle = '#ffd700'; t.ctx.fillRect(0,0,128,128); t.ctx.fillStyle = '#ffecb3'; t.ctx.fillRect(10,10, 50,50);
            textures['gold'] = new THREE.CanvasTexture(t.c);
        }

        function updateSettingsUI() {
            document.getElementById('val-len').innerText = document.getElementById('opt-length').value;
            document.getElementById('val-sens').innerText = document.getElementById('opt-sens').value;
            let fpsVal = document.getElementById('opt-fps').value;
            document.getElementById('val-fps').innerText = fpsVal > 120 ? "Max" : fpsVal;
        }

        function openSettings() {
            isPaused = true;
            document.exitPointerLock();
            document.getElementById('settings-menu').style.display = 'block';
        }

        function closeSettings() {
            let oldLen = gameConfig.levelLength;
            gameConfig.levelLength = parseInt(document.getElementById('opt-length').value);
            gameConfig.sensitivity = parseInt(document.getElementById('opt-sens').value) * 0.0005;
            gameConfig.maxFPS = parseInt(document.getElementById('opt-fps').value);
            fpsInterval = 1000 / gameConfig.maxFPS;
            document.getElementById('settings-menu').style.display = 'none';
            isPaused = false;
            renderer.domElement.requestPointerLock();
            if (oldLen !== gameConfig.levelLength) restartGame(true);
            else animate();
        }

        function init() {
            generateTextures(); 
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x6fa8ff);
            scene.fog = new THREE.Fog(0x6fa8ff, 20, 150);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
            renderer.outputEncoding = THREE.sRGBEncoding; 
            document.body.appendChild(renderer.domElement);

            clock = new THREE.Clock();

            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.7); 
            scene.add(hemiLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
            dirLight.position.set(50, 80, 50); 
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            scene.add(new THREE.AmbientLight(0x404040, 0.5));

            createPlayer();
            createClouds(); 
            generateLevel();

            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', e => keys[e.code] = false);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('resize', onWindowResize);

            renderer.domElement.addEventListener('click', () => {
                if (!isPaused && !isGameOver) renderer.domElement.requestPointerLock();
            });

            fpsInterval = 1000 / gameConfig.maxFPS;
            then = Date.now();
            lastTimeFPS = performance.now();
            animate();
        }

        function restartGame(fullReset) {
            if (fullReset) {
                lives = 3; score = 0; starsCollected = 0;
                currentCheckpoint = { x: 0, y: 5, z: 0, rot: Math.PI };
                generateLevel();
            }
            player.position.set(currentCheckpoint.x, currentCheckpoint.y, currentCheckpoint.z);
            targetRotationY = currentCheckpoint.rot; 
            player.rotation.set(0, targetRotationY, 0);
            velocityX = 0; velocityZ = 0; velocityY = 0;
            jumpCount = 0; currentPlatform = null;
            isBig = false; hasFirePower = false; isImmune = true; 
            setTimeout(() => { isImmune = false; }, 2000); 
            updatePlayerAppearance();
            player.scale.set(1, 1, 1);
            document.getElementById('lives').innerText = lives;
            document.getElementById('score').innerText = score;
            document.getElementById('stars').innerText = starsCollected;
            document.getElementById('game-over').style.display = 'none';
            isGameOver = false; isPaused = false;
            renderer.domElement.requestPointerLock();
        }

        function handlePlayerDeath() {
            if (isImmune || isGameOver) return;
            lives--;
            document.getElementById('lives').innerText = lives;
            if (lives > 0) restartGame(false);
            else endGame(false);
        }

        function onKeyDown(e) {
            if (isGameOver || isPaused) return;
            keys[e.code] = true;
            if (e.code === 'Space' && jumpCount < maxJumps) {
                velocityY = 0.42; jumpCount++; currentPlatform = null;
                if (jumpCount === 2) {
                    createJumpEffect(player.position.x, player.position.y - 0.5, player.position.z);
                    velocityY = 0.45;
                }
            }
            if (e.code === 'KeyF' && hasFirePower) shootFireball();
        }

        function clearWorld() {
            platforms.forEach(p => scene.remove(p.mesh)); platforms = []; movingPlatforms = [];
            stars.forEach(s => scene.remove(s)); stars = []; totalStarsInLevel = 0;
            goombas.forEach(g => scene.remove(g.mesh)); goombas = [];
            thwomps.forEach(t => scene.remove(t.mesh)); thwomps = [];
            bulletBills.forEach(b => scene.remove(b.mesh)); bulletBills = [];
            bullets.forEach(b => scene.remove(b.mesh)); bullets = [];
            powerups.forEach(p => scene.remove(p.mesh)); powerups = [];
            projectiles.forEach(p => scene.remove(p.mesh)); projectiles = [];
            particles.forEach(p => scene.remove(p)); particles = [];
            checkpoints.forEach(cp => scene.remove(cp.mesh)); checkpoints = []; 
            if (flag) { scene.remove(flag); flag = null; }
        }

        function createClouds() {
            clouds.forEach(c => scene.remove(c)); clouds = [];
            const geo = new THREE.BoxGeometry(1, 1, 1);
            const mat = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, transparent: true, opacity: 0.8 });
            for(let i=0; i<30; i++) {
                const cloud = new THREE.Group();
                for(let j=0; j<4; j++) {
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.position.set(j*0.8 + Math.random()*0.5, 0, 0);
                    mesh.scale.set(2 + Math.random(), 1, 1.5);
                    cloud.add(mesh);
                }
                cloud.position.set((Math.random()-0.5)*200, 30 + Math.random()*20, (Math.random()-0.5)*200);
                scene.add(cloud);
                clouds.push({mesh: cloud, speed: 0.02 + Math.random() * 0.03});
            }
        }

        function updateClouds() {
            for(let c of clouds) {
                c.mesh.position.x += c.speed;
                if(c.mesh.position.x > 100) c.mesh.position.x = -100;
            }
        }

        function createCheckpoint(x, y, z) {
            const group = new THREE.Group();
            createPlatform(x, y - 0.5, z, 2.5, 1, 2.5, 'stone', 'box');
            const poleGeo = new THREE.CylinderGeometry(0.05, 0.05, 2, 8);
            const pole = new THREE.Mesh(poleGeo, new THREE.MeshStandardMaterial({ color: 0x888888 })); 
            pole.position.y = 1; group.add(pole);
            const flagMesh = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.6, 0.05), new THREE.MeshStandardMaterial({ color: 0x00FF00, emissive: 0x003300 })); 
            flagMesh.position.set(0.4, 1.6, 0); group.add(flagMesh);
            group.position.set(x, y, z); scene.add(group);
            checkpoints.push({ mesh: group, flagMesh: flagMesh, active: false, pos: { x: x, y: y + 1, z: z } });
        }

        // --- LEVEL GENERATION ---
        function generateLevel() {
            clearWorld();
            createPlatform(0, 0, 0, 8, 1, 8, 'grass', 'box');
            let currentX = 0, currentY = 0, currentZ = 0, currentAngle = -Math.PI; 
            
            const availableBuildings = [
                { type: 'tower', steps: 5 }, { type: 'spiral', steps: 4 }, { type: 'ruins', steps: 6 },
                { type: 'castle', steps: 5 }, { type: 'skyFortress', steps: 8 }, { type: 'clockTower', steps: 5 },
                { type: 'twinTowers', steps: 6 }, { type: 'colosseum', steps: 6 }, { type: 'lighthouse', steps: 4 },
                { type: 'windmill', steps: 4 }, { type: 'greenhouse', steps: 4 }, { type: 'well', steps: 3 },
                { type: 'shrine', steps: 3 }, { type: 'gazebo', steps: 3 }
            ];

            const totalSegments = gameConfig.levelLength;
            for (let s = 0; s < totalSegments; s++) {
                const seg = availableBuildings[Math.floor(Math.random() * availableBuildings.length)];
                for(let i=0; i<seg.steps; i++) {
                    currentAngle += (Math.random() - 0.5) * 0.8;
                    let distance = 4.5 + Math.random() * 3;
                    let nextX = currentX + Math.sin(currentAngle) * distance;
                    let nextZ = currentZ + Math.cos(currentAngle) * distance;
                    let nextY = currentY + (Math.random() * 3.0 - 1.0);
                    if (nextY < -5) nextY = currentY + 2;
                    let w = 3 + Math.random() * 2, d = 3 + Math.random() * 2;
                    if (Math.random() < 0.2) {
                        createMovingPlatform(nextX, nextY, nextZ, 4, 1, 4, Math.random() > 0.5 ? 0x0088ff : 0x9932CC, Math.random() > 0.5 ? 'horizontal' : 'vertical');
                    } else {
                        createPlatform(nextX, nextY, nextZ, w, 1, d, Math.random() > 0.7 ? 'wood' : 'grass', 'box');
                        if (Math.random() < 0.1) createPowerup(nextX, nextY + 1.0, nextZ, Math.random() > 0.5 ? 'mushroom' : 'flower');
                        else if (Math.random() < 0.3) addStar(nextX, nextY + 1.5, nextZ);
                        if (w > 3.5 && Math.random() < 0.3) createGoomba(nextX, nextY + 0.5, nextZ, w, d);
                    }
                    currentX = nextX; currentY = nextY; currentZ = nextZ;
                }
                currentX += Math.sin(currentAngle) * 9; currentZ += Math.cos(currentAngle) * 9;
                createPlatform(currentX, currentY, currentZ, 3, 1, 3, 'stone', 'box');
                let buildX = currentX + Math.sin(currentAngle) * 12, buildZ = currentZ + Math.cos(currentAngle) * 12;
                let exitPoint;
                switch(seg.type) {
                    case 'tower': exitPoint = createBuildingTower(buildX, currentY, buildZ); break;
                    case 'spiral': exitPoint = createSpiralStaircase(buildX, currentY, buildZ); break;
                    case 'ruins': exitPoint = createFloatingRuins(buildX, currentY, buildZ); break;
                    case 'castle': exitPoint = createBuildingCastle(buildX, currentY, buildZ); break;
                    case 'skyFortress': exitPoint = createSkyFortress(buildX, currentY, buildZ); break;
                    case 'clockTower': exitPoint = createClockTower(buildX, currentY, buildZ); break;
                    case 'twinTowers': exitPoint = createTwinTowers(buildX, currentY, buildZ); break;
                    case 'colosseum': exitPoint = createColosseum(buildX, currentY, buildZ); break;
                    case 'lighthouse': exitPoint = createLighthouse(buildX, currentY, buildZ); break;
                    case 'windmill': exitPoint = createWindmill(buildX, currentY, buildZ); break;
                    case 'greenhouse': exitPoint = createGreenhouse(buildX, currentY, buildZ); break;
                    case 'well': exitPoint = createWell(buildX, currentY, buildZ); break;
                    case 'shrine': exitPoint = createShrine(buildX, currentY, buildZ); break;
                    case 'gazebo': exitPoint = createGazebo(buildX, currentY, buildZ); break;
                    default: exitPoint = { x: buildX, y: currentY, z: buildZ };
                }
                createCheckpoint(exitPoint.x, exitPoint.y, exitPoint.z);
                currentX = exitPoint.x; currentY = exitPoint.y; currentZ = exitPoint.z;
            }
            currentX += Math.sin(currentAngle) * 10; currentZ += Math.cos(currentAngle) * 10;
            createPlatform(currentX, currentY, currentZ, 6, 1, 6, 'gold', 'box');
            createFlag(currentX, currentY + 0.5, currentZ);
            document.getElementById('total-stars').innerText = totalStarsInLevel;
        }

        // --- GEBOUWEN ---
        function createSkyFortress(x, y, z) {
            createPlatform(x, y, z, 20, 2, 20, 'stone', 'box');
            createPlatform(x, y+5, z, 10, 8, 10, 'brick', 'box');
            [1, -1].forEach(dx => [1, -1].forEach(dz => createPlatform(x + dx*8, y+4, z + dz*8, 4, 10, 4, 'stone', 'box')));
            createGoomba(x, y+9.5, z, 10, 10); createThwomp(x, y+15, z);
            return { x: x, y: y+9, z: z+12 };
        }
        function createClockTower(x, y, z) {
            createPlatform(x, y, z, 8, 1, 8, 'brick', 'box'); createPlatform(x, y+10, z, 4, 20, 4, 'brick', 'box');
            createPlatform(x, y+18, z+2.1, 2, 2, 0.2, 0xFFFFFF, 'box'); createBulletBill(x, y+2, z+5, Math.PI);
            return { x: x, y: y, z: z+6 };
        }
        function createTwinTowers(x, y, z) {
            createPlatform(x-5, y+6, z, 4, 12, 4, 'stone', 'box'); createPlatform(x+5, y+6, z, 4, 12, 4, 'stone', 'box');
            createPlatform(x, y+10, z, 8, 1, 3, 'wood', 'box'); createGoomba(x, y+10.5, z, 8, 3);
            return { x: x, y: y+10, z: z };
        }
        function createColosseum(x, y, z) {
            createPlatform(x, y, z, 16, 1, 16, 'stone', 'box');
            for(let i=0; i<8; i++) { let a = (i/8)*Math.PI*2; createPlatform(x + Math.cos(a)*7, y+3, z + Math.sin(a)*7, 2, 6, 2, 'brick', 'box'); }
            createThwomp(x, y+5, z); return { x: x, y: y, z: z+9 };
        }
        function createLighthouse(x, y, z) {
            createPlatform(x, y, z, 6, 1, 6, 'stone', 'box'); createPlatform(x, y+4, z, 3, 8, 3, 0xFF0000, 'cylinder');
            createPlatform(x, y+9, z, 2.8, 2, 2.8, 0xFFFFFF, 'cylinder'); createPlatform(x, y+11, z, 3, 1, 3, 'gold', 'box');
            return { x: x, y: y, z: z+5 };
        }
        function createWindmill(x, y, z) {
            createPlatform(x, y, z, 6, 1, 6, 'grass', 'box'); createPlatform(x, y+3, z, 3, 6, 3, 'wood', 'box');
            createPlatform(x, y+4, z+1.6, 8, 0.5, 0.5, 0xFFFFFF, 'box'); createPlatform(x, y+4, z+1.6, 0.5, 8, 0.5, 0xFFFFFF, 'box');
            return { x: x, y: y, z: z+5 };
        }
        function createGreenhouse(x, y, z) {
            createPlatform(x, y, z, 8, 1, 8, 'grass', 'box'); [1,-1].forEach(dx=>[1,-1].forEach(dz=>createPlatform(x+dx*3, y+2, z+dz*3, 0.5, 4, 0.5, 'wood', 'box')));
            createPlatform(x, y+4, z, 7, 0.5, 7, 0x88CCFF, 'box'); createPowerup(x, y+1, z, 'flower');
            return { x: x, y: y, z: z+6 };
        }
        function createWell(x, y, z) {
            createPlatform(x, y, z, 5, 1, 5, 'stone', 'box'); createPlatform(x, y+1, z, 2, 1.5, 2, 0x000000, 'cylinder');
            [1.5, -1.5].forEach(dx => createPlatform(x+dx, y+2, z, 0.5, 4, 0.5, 'wood', 'box'));
            createPlatform(x, y+4, z, 4, 0.5, 2, 'wood', 'box'); return { x: x, y: y, z: z+4 };
        }
        function createShrine(x, y, z) {
            createPlatform(x, y, z, 5, 1, 5, 'stone', 'box'); [1.5,-1.5].forEach(dx=>createPlatform(x+dx, y+1.5, z-1.5, 0.5, 3, 0.5, 0xFF0000, 'box'));
            createPlatform(x, y+3, z-1.5, 4, 0.5, 1, 0x222222, 'box'); addStar(x, y+1, z);
            return { x: x, y: y, z: z+4 };
        }
        function createGazebo(x, y, z) {
            createPlatform(x, y, z, 5, 0.5, 5, 'wood', 'cylinder');
            for(let i=0; i<6; i++) { let a = (i/6)*Math.PI*2; createPlatform(x+Math.cos(a)*2, y+1.5, z+Math.sin(a)*2, 0.2, 3, 0.2, 'white', 'cylinder'); }
            createPlatform(x, y+3, z, 5, 0.5, 5, 0xAA5500, 'cylinder'); return { x: x, y: y, z: z+4 };
        }
        function createFloatingRuins(x, y, z) {
            for(let dx=-8; dx<=8; dx+=4) for(let dz=-8; dz<=8; dz+=4) {
                if(Math.random()>0.2) createPlatform(x+dx, y+Math.random()*0.5, z+dz, 3.8, 1, 3.8, 'stone', 'box');
            }
            createThwomp(x, y + 6, z); return { x: x, y: y, z: z + 10 }; 
        }
        function createSpiralStaircase(x, y, z) {
            createPlatform(x, y + 7.2, z, 2, 14.4, 2, 'brick', 'cylinder');
            for(let i=0; i<12; i++) {
                let a = (i/12)*Math.PI*2, px=x+Math.cos(a)*6, pz=z+Math.sin(a)*6, py=y+(i*1.2);
                createPlatform(px, py, pz, 3, 0.5, 3, 'wood', 'box'); if(i%3===0) addStar(px, py+1, pz);
            }
            createBulletBill(x, y+16, z, 0); return { x: x+6, y: y+13.2, z: z };
        }
        function createBuildingTower(x, y, z) {
            createPlatform(x, y, z, 14, 1, 14, 'stone', 'box');
            [6,-6].forEach(dx=>[6,-6].forEach(dz=>createPlatform(x+dx, y+9, z+dz, 2, 18, 2, 0x505050, 'box')));
            for(let i=1; i<=4; i++) createPlatform(x+(i%2===1?-3.5:3.5), y+i*2.5, z+(i<=2?-3.5:3.5), 4, 1, 4, 'wood', 'box');
            return { x: x-3.5, y: y + 10, z: z+3.5 };
        }
        function createBuildingCastle(x, y, z) {
            createPlatform(x, y, z, 8, 1, 16, 'stone', 'box'); [5,-5].forEach(dx=>createPlatform(x+dx, y+2, z, 1, 4, 16, 'brick', 'box'));
            createThwomp(x, y+5, z); return { x: x, y: y, z: z+9 }; 
        }

        // --- CORE OBJECTS ---
        function createMovingPlatform(x, y, z, w, h, d, color, moveType) {
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), new THREE.MeshStandardMaterial({ color, roughness: 0.2, metalness: 0.6, emissive: 0x111111 }));
            mesh.position.set(x, y, z); mesh.receiveShadow = mesh.castShadow = true; scene.add(mesh);
            const obj = { mesh, w, h, d, isMoving: true, moveType, startPosX: x, startPosY: y, speed: 0.04, range: 3.5, timeOffset: Math.random()*10 };
            platforms.push(obj); movingPlatforms.push(obj);
        }
        function createPlatform(x, y, z, w, h, d, typeOrColor, shapeType) {
            const geo = shapeType === 'cylinder' ? new THREE.CylinderGeometry((w+d)/4, (w+d)/4, h, 24) : new THREE.BoxGeometry(w, h, d);
            let mat;
            if (typeof typeOrColor === 'string' && textures[typeOrColor]) {
                const tex = textures[typeOrColor].clone(); tex.repeat.set(w/2, d/2); tex.needsUpdate = true;
                mat = new THREE.MeshStandardMaterial({ map: tex, roughness: 0.8 });
            } else { mat = new THREE.MeshStandardMaterial({ color: typeOrColor, roughness: 0.6 }); }
            const mesh = new THREE.Mesh(geo, mat); mesh.position.set(x, y, z); mesh.receiveShadow = mesh.castShadow = true; scene.add(mesh);
            platforms.push({ mesh, w, h, d, type: shapeType });
        }
        function createPowerup(x, y, z, type) {
            const group = new THREE.Group();
            group.add(new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 0.4), new THREE.MeshStandardMaterial({color:0xFFFFFF})));
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.5, 12, 12), new THREE.MeshStandardMaterial({color: type === 'mushroom' ? 0xFF0000 : 0xFF8800}));
            head.position.y = 0.3; group.add(head);
            group.position.set(x, y, z); group.userData = { type, startY: y };
            scene.add(group); powerups.push({ mesh: group, type });
        }
        function collectPowerup(type) {
            const msg = document.getElementById('powerup-msg'); msg.style.display = 'block';
            if (type === 'mushroom') { msg.innerText = "SUPER MUSHROOM!"; if (!isBig) { player.scale.set(1.5,1.5,1.5); isBig = true; velocityY = 0.2; } }
            else { msg.innerText = "FIRE FLOWER!"; hasFirePower = true; updatePlayerAppearance(); }
            score += 500; setTimeout(()=>msg.style.display='none', 1000);
        }
        function updatePlayerAppearance() {
            player.children.forEach(c => { if(c.material) c.material.color.setHex(hasFirePower ? 0xFFFFFF : 0xFF0000); });
        }
        function shootFireball() {
            const fb = new THREE.Mesh(new THREE.SphereGeometry(0.25, 8, 8), new THREE.MeshStandardMaterial({color: 0xFF4400, emissive: 0xFF0000}));
            const dx = Math.sin(player.rotation.y), dz = Math.cos(player.rotation.y);
            fb.position.set(player.position.x + dx, player.position.y + 0.5, player.position.z + dz);
            fb.userData = { vx: dx*0.4, vz: dz*0.4, life: 60 }; scene.add(fb); projectiles.push({ mesh: fb });
        }
        function createJumpEffect(x, y, z) {
            for(let i=0; i<4; i++) {
                const p = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 0.2), new THREE.MeshBasicMaterial({ color: 0xFFFFFF }));
                p.position.set(x, y, z); p.userData = { vx: (Math.random()-0.5)*0.1, vy: Math.random()*0.1, vz: (Math.random()-0.5)*0.1, life: 1.0 };
                scene.add(p); particles.push(p);
            }
        }
        function createFlag(x, y, z) {
            flag = new THREE.Group();
            const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 4, 8), new THREE.MeshStandardMaterial({color:0x888888}));
            pole.position.y = 2; flag.add(pole);
            const sail = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1, 0.1), new THREE.MeshStandardMaterial({color:0x00ff00}));
            sail.position.set(0.75, 3.5, 0); flag.add(sail);
            flag.position.set(x, y, z); scene.add(flag);
        }
        function addStar(x, y, z) {
            const star = new THREE.Mesh(new THREE.OctahedronGeometry(0.4), new THREE.MeshStandardMaterial({color: 0xffd700, emissive: 0xaa6600}));
            star.position.set(x, y, z); scene.add(star); stars.push(star); totalStarsInLevel++;
        }
        function createBulletBill(x, y, z, angle) {
            const bb = new THREE.Mesh(new THREE.BoxGeometry(1.5,1.5,1.5), new THREE.MeshStandardMaterial({ color: 0x111111 }));
            bb.position.set(x, y, z); bb.rotation.y = angle; scene.add(bb);
            bulletBills.push({ mesh: bb, timer: 0, direction: angle + Math.PI });
        }
        function createThwomp(x, y, z) {
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(2, 2.5, 2), new THREE.MeshStandardMaterial({ color: 0x777777 }));
            mesh.position.set(x, y, z); scene.add(mesh);
            thwomps.push({ mesh, homeY: y, state: 'IDLE', timer: 0, speed: 0 });
        }
        function createPlayer() {
            player = new THREE.Group();
            const body = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshStandardMaterial({color:0xff0000})); body.castShadow = true; player.add(body);
            const cap = new THREE.Mesh(new THREE.BoxGeometry(1.05, 0.2, 0.5), new THREE.MeshStandardMaterial({color:0xb83000})); cap.position.set(0, 0.2, 0.4); player.add(cap);
            const pants = new THREE.Mesh(new THREE.BoxGeometry(1.02, 0.4, 1.02), new THREE.MeshStandardMaterial({color:0x0000aa})); pants.position.set(0, -0.3, 0); player.add(pants);
            player.position.set(0, 5, 0); scene.add(player);
        }
        function createGoomba(x, y, z, pw, pd) {
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, 0.8), new THREE.MeshStandardMaterial({ color: 0x8B4513 }));
            mesh.position.set(x, y, z); scene.add(mesh);
            const axis = pw > pd ? 'x' : 'z';
            goombas.push({ mesh, axis, start: axis==='x'?x:z, limit: (axis==='x'?pw:pd)/2 - 0.5, speed: 0.04, dir: 1 });
        }

        // --- TICK LOGICA ---
        function animate() {
            requestAnimationFrame(animate);
            if (isPaused || isGameOver) return;
            now = Date.now(); elapsed = now - then;
            frameCount++;
            if (now - lastTimeFPS >= 1000) { document.getElementById('fps-counter').innerText = frameCount; frameCount = 0; lastTimeFPS = now; }

            if (elapsed > fpsInterval) {
                then = now - (elapsed % fpsInterval);
                const time = clock.getElapsedTime();

                updateClouds();
                
                // Particles & Projectiles
                for(let i=particles.length-1; i>=0; i--) {
                    const p = particles[i]; p.position.x += p.userData.vx; p.position.y += p.userData.vy; p.position.z += p.userData.vz;
                    p.userData.life -= 0.03; if(p.userData.life <= 0) { scene.remove(p); particles.splice(i, 1); }
                }
                for(let i=projectiles.length-1; i>=0; i--) {
                    const p = projectiles[i].mesh; p.position.x += p.userData.vx; p.position.z += p.userData.vz;
                    p.userData.life--; if(p.userData.life<=0) { scene.remove(p); projectiles.splice(i,1); }
                }

                // Collectables
                for(let i=stars.length-1; i>=0; i--) {
                    stars[i].rotation.y += 0.05;
                    if(player.position.distanceTo(stars[i].position) < 1.5) { 
                        scene.remove(stars[i]); stars.splice(i, 1); starsCollected++; score += 100;
                        document.getElementById('stars').innerText = starsCollected; document.getElementById('score').innerText = score;
                    }
                }
                for(let i=powerups.length-1; i>=0; i--) {
                    const p = powerups[i].mesh; p.rotation.y += 0.03; p.position.y = powerups[i].userData.startY + Math.sin(time*2)*0.2;
                    if(player.position.distanceTo(p.position) < 1.5) { collectPowerup(powerups[i].userData.type); scene.remove(p); powerups.splice(i, 1); }
                }

                // Movement
                let inputX = 0, inputZ = 0;
                if (keys['KeyW']) inputZ += 1; if (keys['KeyS']) inputZ -= 1;
                if (keys['KeyA']) inputX += 1; if (keys['KeyD']) inputX -= 1;
                if (inputX || inputZ) {
                    const angle = targetRotationY + Math.atan2(inputX, inputZ);
                    velocityX += Math.sin(angle) * acceleration; velocityZ += Math.cos(angle) * acceleration;
                    player.rotation.y = angle;
                }
                velocityX *= friction; velocityZ *= friction;
                
                // Wall Collision
                const nextX = player.position.x + velocityX, nextZ = player.position.z + velocityZ;
                let wallHit = false;
                for(let p of platforms) {
                    if (player.position.y > p.mesh.position.y - p.h/2 && player.position.y < p.mesh.position.y + p.h/2) {
                        if (Math.abs(nextX - p.mesh.position.x) < p.w/2 + 0.4 && Math.abs(nextZ - p.mesh.position.z) < p.d/2 + 0.4) { wallHit = true; break; }
                    }
                }
                if (!wallHit) { player.position.x = nextX; player.position.z = nextZ; }

                // Gravity & Platforms
                velocityY += gravity; player.position.y += velocityY;
                let grounded = false;
                for(let p of platforms) {
                    if (Math.abs(player.position.x - p.mesh.position.x) < p.w/2 + 0.4 && Math.abs(player.position.z - p.mesh.position.z) < p.d/2 + 0.4) {
                        const top = p.mesh.position.y + p.h/2;
                        if (velocityY <= 0 && player.position.y - 0.5 >= top - 0.5 && player.position.y - 0.5 + velocityY <= top) {
                            player.position.y = top + 0.5; velocityY = 0; jumpCount = 0; currentPlatform = p; grounded = true; break;
                        }
                    }
                }

                // Moving Platforms
                for(let p of movingPlatforms) {
                    const offset = Math.sin(time*2 + p.timeOffset) * p.range;
                    const oldX = p.mesh.position.x, oldY = p.mesh.position.y;
                    if(p.moveType === 'horizontal') p.mesh.position.x = p.startPosX + offset;
                    else p.mesh.position.y = p.startPosY + offset;
                    if(currentPlatform === p) { player.position.x += (p.mesh.position.x - oldX); player.position.y += (p.mesh.position.y - oldY); }
                }

                // Enemies
                for(let i=goombas.length-1; i>=0; i--) {
                    const g = goombas[i];
                    if (g.axis === 'x') { g.mesh.position.x += g.speed * g.dir; if (Math.abs(g.mesh.position.x - g.start) > g.limit) g.dir *= -1; }
                    else { g.mesh.position.z += g.speed * g.dir; if (Math.abs(g.mesh.position.z - g.start) > g.limit) g.dir *= -1; }
                    if (player.position.distanceTo(g.mesh.position) < 1.3) {
                        if (velocityY < -0.05 && player.position.y > g.mesh.position.y + 0.5) { scene.remove(g.mesh); goombas.splice(i, 1); velocityY = 0.25; score += 200; document.getElementById('score').innerText = score; }
                        else handlePlayerDeath();
                    }
                }
                for(let t of thwomps) {
                    const d = player.position.distanceTo(t.mesh.position);
                    if(t.state === 'IDLE' && d < 5) t.state = 'FALLING';
                    if(t.state === 'FALLING') { t.speed += 0.04; t.mesh.position.y -= t.speed; if(t.mesh.position.y < t.homeY-5) { t.state = 'WAITING'; t.speed = 0; } }
                    if(t.state === 'WAITING') { t.timer++; if(t.timer>60) { t.state = 'RISING'; t.timer=0; } }
                    if(t.state === 'RISING') { t.mesh.position.y += 0.05; if(t.mesh.position.y >= t.homeY) t.state = 'IDLE'; }
                    if(d < 1.8) handlePlayerDeath();
                }
                for(let bb of bulletBills) {
                    bb.timer++;
                    if(bb.timer > 180) {
                        if(player.position.distanceTo(bb.mesh.position) < 35) {
                            const b = new THREE.Mesh(new THREE.BoxGeometry(0.6,0.6,0.6), new THREE.MeshStandardMaterial({color:0x222222}));
                            b.position.copy(bb.mesh.position);
                            b.userData = { vx: Math.sin(bb.direction)*0.25, vz: Math.cos(bb.direction)*0.25, life: 200 };
                            scene.add(b); bullets.push(b);
                        }
                        bb.timer = 0;
                    }
                }
                for(let i=bullets.length-1; i>=0; i--) {
                    const b = bullets[i]; b.position.x += b.userData.vx; b.position.z += b.userData.vz;
                    if(b.position.distanceTo(player.position) < 1.2) handlePlayerDeath();
                    b.userData.life--; if(b.userData.life<=0) { scene.remove(b); bullets.splice(i, 1); }
                }

                for(let cp of checkpoints) {
                    if(!cp.active && player.position.distanceTo(cp.mesh.position) < 3) {
                        cp.active = true; cp.flagMesh.material.color.setHex(0xFF0000);
                        currentCheckpoint = { x: cp.pos.x, y: cp.pos.y, z: cp.pos.z, rot: player.rotation.y };
                        const msg = document.getElementById('checkpoint-msg'); msg.style.display='block'; setTimeout(()=>msg.style.display='none', 2000);
                    }
                }

                if (flag && player.position.distanceTo(flag.position) < 2.5) endGame(true);
                if (player.position.y < -30) handlePlayerDeath();

                updateCamera();
                renderer.render(scene, camera);
            }
        }

        function updateCamera() {
            const dist = 8;
            const x = player.position.x - Math.sin(targetRotationY)*Math.cos(targetRotationX)*dist;
            const y = player.position.y + Math.sin(targetRotationX)*dist + 1.5;
            const z = player.position.z - Math.cos(targetRotationY)*Math.cos(targetRotationX)*dist;
            camera.position.lerp(new THREE.Vector3(x, y, z), 0.1);
            camera.lookAt(player.position.x, player.position.y + 1, player.position.z);
        }

        function onMouseMove(e) {
            if (isPaused || isGameOver) return;
            if (document.pointerLockElement === renderer.domElement) {
                targetRotationY -= e.movementX * gameConfig.sensitivity;
                targetRotationX += e.movementY * gameConfig.sensitivity;
                targetRotationX = Math.max(0.1, Math.min(1.4, targetRotationX));
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function endGame(win) {
            isGameOver = true; document.exitPointerLock(); document.getElementById('game-over').style.display = 'block';
            document.getElementById('status-text').innerText = win ? "GEWONNEN!" : "GAME OVER";
        }

        window.onload = init;
    </script>
</body>
</html>